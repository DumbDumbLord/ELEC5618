                        Initial Quality Assurance Mechanisms

1. Walkthrough Procedures:
    Freeplane employs a multi-layered QA approach combining automated testing, peer reviews, and community-driven validation. 
    Below are the key procedures and their implementation:
    I. Code Review Walkthroughs
      Purpose: Ensure code correctness, adherence to standards, and maintainability.
      Steps Involved:
        a. Pull Request Submission:
          Contributors submit PRs from feature/fix branches to the develop branch.
          PRs must include:
            - A description linking to the relevant GitHub issue.
            - Unit/UI test updates (if applicable).
            - Javadoc comments for new methods.
        b. Automated Checks:
          CI Pipelines run:
            - Compilation checks.
            - Unit tests.
            - Code coverage metrics.
        c. Manual Code Review:
          Core Maintainers review:
            - Architectural consistency.
            - Compliance with coding conventions.
            - Edge-case handling and error logging.
          Feedback Loop:
            - Reviewers request revisions via PR comments.
            - Contributors amend code and push updates.
        d. Approval & Merge:
          PRs are merged into develop only after:
            - All CI checks pass.
            - At least one maintainer approves.
        
        Key Participants:
        - Contributors: Implement code and address feedback.
        - Maintainers: Enforce standards and validate logic.
        - CI Bots: Automate preliminary checks.
    
    II. Testing Walkthroughs
      Purpose: Validate functionality, regression safety, and cross-platform compatibility.
      Steps Involved:
        a. Unit Testing:
          - Developers write JUnit tests for core logic.
          - Tests are stored in /src/test/java and executed via ant test.
        b. GUI Testing:
          Automated UI Tests:
            - Custom frameworks simulate user interactions.
            - Executed during CI to detect visual/functional regressions.
          Manual Exploratory Testing:
            - Testers (community volunteers) validate workflows on Windows, macOS, and Linux.
        c. Integration Testing:
          - Plugins are tested in isolation and alongside core features.
          - Example: LaTeX plugin compatibility with mind-map exports.
        d. Performance Profiling:
          - Maintainers use profiling tools to identify memory leaks or slowdowns.
        
        Key Participants:
          - Developers: Write and maintain test cases.
          - Testers: Execute manual tests and report issues.
          - Community Users: Validate pre-release builds.
    
    III. Documentation & Requirements Walkthroughs
      Purpose: Ensure clarity, usability, and alignment with user needs.
      Steps Involved:
        a. Functional Specification Review:
          New features require a GitHub issue or Wiki page outlining:
            - Use cases.
            - UI mockups.
            - Technical dependencies.
        b. User Documentation Updates:
          - Contributors update the Freeplane Wiki for new features.
          - Maintainers verify documentation matches implementation.
        c. Accessibility Audits
          - Periodic checks for keyboard navigation, screen-reader compatibility, and UI consistency.
        
        Key Participants:
          - Documentation Maintainers: Edit and organize Wiki content.
          - UX Contributors: Review UI/UX changes.
    
    IV. Release Candidate Walkthroughs
      Purpose: Final validation before public releases.
      Steps Involved:
        a. Release Packaging:
          - Maintainers use Ant scripts to generate installers for all platforms.
        b. Smoke Testing:
          - Core functionalities are tested on clean environments.
        c. Community Beta Testing:
          - Pre-release builds are shared via forums or GitHub Releases for user feedback.
        d. Hotfix Handling:
          - Critical bugs reported post-release are patched via master branch hotfixes.
      
      Key Participants:
        - Release Managers: Coordinate packaging and testing.
        - Beta Testers: Provide real-world feedback.

2. Code Review Process: 
    The code review process mainly includes standard git collaboration methods. Freeplane is an open source project hosted on github, with the current 
    version 1.12.x being the main default branch. Changes are made in new branches which can originate from the main branch, or from another branch/version. 
    The changes from branches are merged to main via pull requests, where the main developer and project owner Dimitry Polivaev, is able to review the code, 
    then messages the contributor and rejects or accepts the pull request. Git allows for seamless collaboration and version control which provide great 
    flexibility and ensures that the code stays working and effective. Hence the code review mainly focuses on the usage of pull requests and 
    branches to review code with seemingly only the developer Dimitry Polivaev participating in it. For our team the quality manager will be the main person 
    responsible for code reviewing, while some team members occasionally accept some pull requests. 


3. Software Evaluation Process: 
    1) User Testing
    Freeplane refactored the original FreeMind code to quickly add features requested by users, such as labeled graphical links, spell checking, and improved filtering. These enhancements stemmed from close attention to user feedback. 
    Whenever new features or versions appear, community members test and discuss them, which led to better filtering usability (e.g., filtering menus, icons, history, and date-based filtering). 
    Freeplane also collaborated with the University of Oulu’s User Experience Research Group; their suggestions (noted in version 1.8.3’s changelog) helped further improve usability.
    
    2) Performance Benchmarking and Optimization
    The Freeplane team regularly evaluates and optimizes performance for tasks like map rendering and filtering—examples include quicker compound filtering in version 1.8.6 and enhanced rendering in version 1.8.7. 
    As mind maps grow larger, Freeplane’s updates (e.g., in versions 1.5.13 and 1.6.13) focus on speeding up loading and handling of giant maps with many elements (such as SVG icons). 
    Memory management also improved, like reducing resource use for external map zooming (1.2.13 beta) and checking available memory at startup on Windows (1.0.39 beta). 
    Many performance fixes arose from addressing bugs (e.g., hierarchical icons slowing performance in 1.0.34 beta, memory leaks in the long node editor in 1.0.36 beta, and Java heap overflows in FreeMind 0.9.0 Beta18). 
    They also sped up startup by delaying certain component loading, such as the spell checker dictionary. Additionally, a “Release Smoke Test” includes performance checks like rapid text entry and node folding/unfolding to see how the software behaves under heavier use.
    
    3) Automated Analysis Tools
    Freeplane integrated automated code analysis and architecture testing to improve code quality. A key example is ArchUnit, which checks code architecture rules; in version 1.11.11, Freeplane began logging and analyzing any violations. 
    Version 1.11.9 added a JVM code explorer mode for visualizing dependencies. Using Gradle, Freeplane also incorporates unit tests (e.g., adding new JUnit tests when fixing HTML export issues). 
    Since version 1.x, Freeplane has featured automatic error reporting: if an unhandled exception occurs, the software prompts users to send an error log, allowing developers to identify and fix issues without relying solely on full-scale user testing.

4. Quality Assurance Roles in the Team: 
    Quality Manager
      Role Description: The role of quality manager is usually performed by a core maintainer. The quality manager is the strategic leader of quality assurance and is responsible for setting and overseeing quality standards and processes throughout the project.
      Specific responsibilities:
      Define quality objectives: such as ensuring that each release, such as alpha-1.9.0-pre05, passes basic functional testing and is free of critical defects. As you can see from the GitHub Releases page, the maintainer releases releases regularly with an update log.
      Review Pull Requests to ensure code conforms to coding specifications, such as Java's OSGi and Swing standards.
      Decide when to release the new version and ensure that the version is fully verified, such as functional testing and stability checking.
      Community feedback Integration: Gather user feedback and prioritize quality Issues through GitHub Discussions and Issues, such as#2271, bug report dated February 1, 2025.
    Quality Engineer
      Role Description: Quality engineers are typically active code contributors to a project who support the quality assurance process through technical means.
      Specific responsibilities:
      Write automated tests: Write automated test scripts for core functions, such as mind map editing, file export to ensure functional correctness.
      Bug management: Analyze bug reports in GitHub Issues, reproduce issues and submit fixes.
      Continuous Integration Optimization: Maintain the test pipeline configuration for GitHub Actions
      Participate in code reviews: Provide technical feedback in Pull Requests reviews to help improve code quality.
    Test Lead
      Role Description: The test lead is responsible for coordinating testing activities and ensuring that new features and fixes are fully validated. In Freeplane, this role may be filled by active testers or volunteers in the community.
      Specific responsibilities:
      Design test plan:Develop test cases for new features or major changes, covering major use cases.The repository has multiple open bugs and feature requests, such as #2301, #2291, indicating that the community is continuously tracking and improving quality.
      Perform manual testing, download pre-release versions ,such as Assets of alpha-1.9.0-pre05, test cross-platform compatibility (Windows, macOS, Linux), and user experience.
      Feedback test results: Submit a detailed test report on GitHub Issues and record the problems found.
      oordinate community testing: For example, launch a test call in Discussions to encourage other users to participate in validating a new feature or fix.


5. Software Testing Methods: 
    (EventTest.java)
    1. Unit Test
      This code is a unit test that verifies the functionality of the language selection menu through the JUnit framework and ensures that the menu items correctly update their selected state after being clicked.
    
    2. Test Method
      Initialization: Create two menus menu1 and menu2 and use SpellChecker.
      createLanguagesMenu() to fill the menu items.
      Assertions:
      Use assertEquals() to check whether the names and selected states of the two menu items are the same.
      Use assertTrue() and assertFalse() to check the selected state of the menu items after clicking.
      User interaction simulation: Use doClick(0) to simulate the user clicking on the menu item to switch the selected language.
      Synchronous check: Verify that the states between menu1 and menu2 are consistent.
    
    3. Threading
      Use Thread.sleep(10) to wait for asynchronous operations to complete, but this method is not the best practice.

    (MemoryTest.java)
    1. Unit Testing
      This code includes two primary memory leak tests, using the JUnit framework to verify whether methods in the SpellChecker class exhibit memory leaks.
    
    2. Test Methods
      testCreateLanguagesMenu: This test creates a language menu and repeatedly calls SpellChecker.createLanguagesMenu() to generate 10,000 menu items. It then compares the memory usage before and after the method execution to ensure there is no excessive increase, which would indicate a memory leak.
      The usedMemory() method is used to track memory usage, and if the memory grows beyond a set threshold, it is considered a memory leak.
      testRegister: This test creates a large text and registers it with the SpellChecker. It then creates multiple JTextPane objects, registering each one with the SpellChecker, and monitors memory usage. If memory usage grows too much, it suggests a memory leak.
      Similar to the previous test, it uses the usedMemory() method to monitor memory and prints out memory usage details.
    
    3. Memory Usage Monitoring
      usedMemory() Method: This method forces garbage collection using System.gc() and monitors the difference between runtime.totalMemory() and runtime.freeMemory to track memory usage.
      If memory usage increases without significant reduction, it indicates a potential memory leak.
    
    4. Thread Handling
      Thread.sleep(10) is used to allow garbage collection to complete and ensure that memory management processes have time to execute properly.
    
    5. Failure Conditions
      If memory usage exceeds a predefined threshold (such as 100,000 or 1,000,000 bytes), the test calls the fail() method, marking the test as failed and reporting a memory leak.

    (QualityTest.java)
    JUnit Assertions:
    assertEquals(expected, actual): Verifies that the actual value matches the expected value (e.g., testing string conversions and unit conversions).
    assertNull(value): Checks if a value is null (e.g., when parsing a null string).
    assertThrows(expectedException.class, executable): Verifies that a specific exception is thrown (e.g., testing for IllegalStateException when a negative quantity is used).
    AssertJ Assertions:
    assertThat(value).isEqualTo(expected): Fluent and expressive assertion for equality checks (e.g., testing value conversions, unit transformations, and the rounding of values).
    assertThat(value).isEqualTo(new Quantity(...)): Verifies if objects are equal based on custom logic (e.g., verifying unit conversions).
    Edge Case and Boundary Testing:
    Tests include scenarios with edge values like zero or negative quantities, ensuring the system handles them correctly.
    Tests also cover cases such as rounding behavior when converting between units.
    Missing testing methods:
    Integration Testing: Test how multiple modules work together, such as how Quantity interacts with the UI, database, or API.
    Database interaction tests (if Quantity is stored in a database).
    Component interaction tests (if Quantity is transferred via an API or file system).
    End-to-end testing (E2E Testing): simulate user behavior and test whether the functions of the entire system are working properly.
    Web UI testing (using Selenium/Cypress).
    REST API testing (if Quantity is accessed through API, RestAssured can be used).

    

6. Identified Gaps and Recommendations: (Highlight any shortcomings in the quality assurance process and provide suggestions for improvement.)
    a.Insufficient coverage of automated tests
      Problem:
        Freeplane relies too much on manual testing, and the testing process is inefficient and prone to human errors.
        The coverage of unit tests, integration tests, and UI tests is limited, which may lead to new bugs being introduced when code changes are made without being discovered in time.
      Suggestions for improvement:
        Introduce automated testing frameworks, such as: JUnit (unit testing), Mockito (simulated dependencies),TestContainers (integration testing of external dependencies such as databases), Selenium or Cypress (UI automated testing). Ensure that the test coverage reaches more than 80% to reduce the occurrence of regression problems.

    b.Lack of continuous integration and continuous deployment (CI/CD)
      Problem:
        There is no automated test pipeline, and the test will not be automatically run after the code is submitted.
        Developers may merge the code directly without sufficient testing, which may cause bugs in the production environment.
      Suggestions for improvement:
        Build a CI/CD pipeline (GitHub Actions or GitLab CI/CD) to realize automatic testing and building when the code is submitted.
        Establish a code review mechanism of "testing before merging" to ensure the stability of each update.
