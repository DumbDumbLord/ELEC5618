                            Project Description

1. Functionality:(Provide a concise description of what the program does.)
    Freeplane is a mind mapping and idea organization tool that helps users visually structure, manage, and develop their plans or thoughts.
    It is designed for users who need an effective way to brainstorm, organize information, and communicate ideas clearly.
    It serves students, educators, business professionals, researchers, and creatives, offering a highly flexible solution for organizing and managing ideas efficiently.
    
    Key Features:
    Mind Mapping & Organization: Create and structure hierarchical diagrams to manage ideas effectively.
    Rich Formatting Options: Customize nodes with styles, colors, icons, hyperlinks, and images for better visualization.
    Formulas & Command Search: Utilize formulas for calculations and quickly find commands for efficiency.
    Task & Project Management: Assign priorities, due dates, and progress indicators to tasks.
    Add-ons & Extensions: Extend functionality with custom scripts and plugins to tailor the experience.
    Collapsible Structures: Expand or collapse branches to focus on specific sections.
    Automation & Scripting: Use Groovy scripting to automate repetitive tasks.
    Import & Export Support: Save and open files in various formats (XML, HTML, PDF, etc.).
    Security & Encryption: Protect sensitive data with password encryption.
    Cross-Platform & Open-Source: Free to use, modify, and share, making it a powerful alternative to paid tools like Xmind or MindMeister.

2. Target Users and Purpose:(Describe the type of user most likely to use this program and why they would use it.)
    This program is likely used to organize ideas and to better develop or communicate them to others or for personal use. 
    Users could include students, teachers, office workers, and management teams who need a structured way to brainstorm, plan, or document information.
    Freeplane's flexibility, open-source nature, and cross-platform compatibility make it an attractive choice for those looking for a customizable, free alternative to commercial mind mapping tools like Xmind or MindMeister. 
    It is also well-suited for casual and power users who value productivity and creativity in their workflows.

    Key Use Cases:
    Students & Educators – For note-taking, lesson planning, and research organization.
    Business Professionals & Managers – For project management, workflow visualization, and decision-making.
    Researchers & Writers – For structuring reports, thesis planning, and organizing references.
    Software Developers & Engineers – For brainstorming software architecture, documenting workflows, and problem-solving.
    Creatives & Casual Users – For journaling, storyboarding, and enhancing personal productivity.


3. Installation Process:(Provide a step-by-step guide for a novice user to install the program.)
    Visit https://sourceforge.net/projects/freeplane/.
    Download the latest version of Freeplan.
        Windows: Double-click the .exe file and follow the installation wizard.
        Mac: Open the .dmg file, then drag Freeplane to the Applications folder.
        Linux: Extract the .tar.gz file and follow the installation instructions in the provided README.

    Go to the Repository(https://github.com/freeplane/freeplane).
    Download the Project as a ZIP File and extract the ZIP File.
    Install Required Software Ensure that you have the following installed:
        Java Development Kit (JDK 17 or later) → Download from Oracle JDK or use OpenJDK.
        Gradle (used for building the project) → Download from Gradle website or use package managers like brew install gradle (Mac) or choco install gradle (Windows).
        Visual Studio Code (VS Code) → Download from VS Code website.
    Open the Project in VS Code and set Up the development environment.
    Run the build file 'build.gradle’ and run Freeplane.



4. Upgrade Process:(Each team selects an open-source project and identifies a software quality feature to improve. The team then collaborates to implement the upgrade, with each member playing a specific role. Describe the collaboration process, role assignments, and how the feature was built from scratch.)
  a. Collaboration Process
      Quality Planning:
        Kick-off Meeting:
          Assemble key participants: Project Manager, Lead Developer, QA, UX/UI Designer, DevOps, and Community Representatives.
          Review current quality issues and user feedback (from GitHub Issues, Discussions, and direct user input) to identify the improvement areas.
          
        Define Scope and Priorities:
          Prioritize the 15 improvement aspects based on impact, effort, and community feedback.
          Develop detailed requirement documents for each aspect.
         
      Quality Assurance:
        Prototype Development:
          Develop a proof-of-concept or a minimal viable version of new features to validate design decisions.
          
        Incremental Implementation:
          Use feature branches for each major improvement.
          Follow coding standards and best practices; maintain modularity for future extensions.
          
        Peer Review Process:
          Developers submit pull requests which are reviewed by peers, the lead developer, and QA.
          Automated code analysis tools (e.g., static analysis, test coverage reports) support this process.
          
        Merge and Integration:
          After successful reviews and testing, merge feature branches into the main branch.
          
        Automated Testing:
          Implement unit tests, integration tests, and UI tests using a CI pipeline.
          
        Manual Testing:
          QA conducts exploratory and regression testing.
          Security tests are performed to ensure vulnerability-free updates.
          
        Walkthrough Sessions:
          Testing Walkthrough: QA and developers jointly review test cases, results, and bug reports to ensure comprehensive coverage.

      Quality Control
        Rigorous Testing Regimes
          Both automated and manual testing are used to monitor project results. Unit tests, integration tests, and UI tests are implemented to check that the specific outputs comply with quality standards.

        Monitoring and Feedback Loops
          Regular bug tracking, error logging, and community feedback help the team promptly address any deviations from the quality standards.

        Enforcing Standards
          Code reviews and strict merge criteria ensure that all development follows the agreed-upon procedures and quality requirements.

  b. Role Assignments
    Project Lead: Yujie Dai
      - Overall coordination
      - Task prioritization
      - Backend/core code contributions
      
      Reason: With a strong foundation in Java, experience in backend/full-stack development, and software engineering expertise, Yujie can coordinate tasks, prioritize work, and contribute to core backend code. Her full-stack experience ensures a holistic view of the project.
      
    UX/UI Designer: Zeyu Li
      - Redesigning the interface
      - Accessibility improvements
      
      Reason: Familiarity with HTML, CSS, JavaScript, and game development (Unity) highlights frontend and design capabilities. This aligns with redesigning interfaces and improving accessibility.
      
    Backend: Hongyi Chen
      - Performance optimization
      - Feature integration
      
      Reason: Proficient in Python, Java, and C, with experience in both frontend and backend development. His versatility and math/logic background (BSc in Maths) suit performance optimization and complex feature integration.
      
    QA & Testing Engineer: Yicheng Xie
      - Writing and running tests
      - Bug triage
      
      As a newer developer with foundational Python knowledge, QA/testing offers hands-on learning while ensuring software quality. Testing will help Yicheng understand the codebase and software practices.
      
    Documentation & Tools: Yuanhao Cai
      - Writing docs
      - Managing dev tools/CI/CD
      
      With an engineering background (C++, Matlab), Yuanhao can manage CI/CD pipelines and documentation systematically. This role leverages organizational skills without requiring deep frontend/backend expertise.
      

  c. The process builds features from scratch by following these key steps:

      Planning & Design:
      Define requirements and quality standards, then create prototypes and design walkthroughs to validate ideas.

      Incremental Development:
      Develop the feature in isolated branches, adhering to coding best practices and using peer reviews for quality checks.

      Continuous Testing & Integration:
      Run automated and manual tests through a CI/CD pipeline, ensuring the new code meets all quality standards before merging into the main branch.

      Final Review:
      Conduct a final walkthrough to confirm that the feature integrates seamlessly and meets the set requirements.


5. Proposed Improvements:(Each team member must propose at least three aspects of the product that need improvement. The aspects proposed by each team member cannot be repeated.)

  (1) Performance Optimization
    Issue: Slow response times and inefficient memory management
    Solution: Optimize code and algorithms, improve memory handling, and boost overall performance
    
  (2) Code Modularity & Refactoring
    Issue: Monolithic legacy code that is difficult to maintain
    Solution: Refactor the codebase into modular components to reduce technical debt and simplify future enhancements
    
  (3) Enhanced Plugin Architecture
    Issue: Inflexible plugin system limiting extensibility
    Solution: Redesign the plugin framework for easier integration and extension by developers
    
  (4) Automated testing and increased coverage
    Issue: Insufficient testing leading to undetected bugs and regressions
    Solution: Implement comprehensive unit, integration, and UI tests with automation via a CI/CD pipeline
    
  (5) User experience enhancements
    Issue: Complex navigation and interactions causing user confusion
    Solution: Redesign user flows and interfaces to be more intuitive and accessible
  
  (6) Improved documentation
    Issue: Sparse or outdated documentation hindering onboarding and maintenance
    Solution: Update and expand user and developer documentation with clear guidelines and examples

  (7) Internationalization & Localization
    Issue:Limited language support and regional customization
    Solution:Add multi-language support and localization features for broader accessibility

  (8) Simplified Installation Process
    Issue:Complicated installation procedures deterring new users
    Solution:Simplify and automate the installation process for easier setup across different platforms
    
  (9) Accessibility Improvements
     Issue:Lack of compliance with accessibility standards (e.g., keyboard navigation, screen readers)
     Solution:Implement accessibility features such as keyboard shortcuts, high-contrast modes, and screen reader support
  
  (10)
    Issue:Potential vulnerabilities and outdated security practices
    Solution:Update security protocols, conduct regular vulnerability scans, and implement robust error handling
  
  (11)
    Issue:Manual testing and deployment causing delays and errors
    Solution:Set up continuous integration and deployment pipelines to automate builds, tests, and releases
  
  (12)
    Issue:Insufficient error tracking and logging hindering effective debugging
    Solution:Integrate comprehensive logging, error monitoring, and alerting systems
  
  (13) Improved UI
    Issue:Currently the UI is not very appealing and with a lot of information clustered together
    Solution: Increase outline for tabs, increase margins for mindmap boxes/nodes and also move around for font, size, etc to a left tab to improve space
    
  (14) Resizing Nodes Using Mouse
    Issue: Nodes currently can't be resized dynamically using mouse
    Solution: Make nodes resizable using mouse
    
  (15) Default/Template node/mindmap designs
    Issue: The software currently lack any templates for nodes or mindmap from the software itself, which would be helpful to the user
    Solution: Add in templates for nodes/mindmaps




