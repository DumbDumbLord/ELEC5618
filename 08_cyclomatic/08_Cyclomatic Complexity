Method/Function 1

Selected Method:
freeplane/src/main/java/org/freeplane/features/attribute/AttributeContainsCondition.java
public boolean checkNode(final NodeModel node) {
       final IAttributeTableModel attributes = NodeAttributeTableModel.getModel(node);
       final TextController textController = TextController.getController();
       for (int i = 0; i < attributes.getRowCount(); i++) {
           if(attribute.equals(AttributeConditionController.ANY_ATTRIBUTE_NAME_OR_VALUE_OBJECT)){
               if (checkContent(attributes.getValueAt(i, 0)))
                   return true;


           }
           else if(! attributes.getValueAt(i, 0).equals(attribute)) {
               continue;
           }
           final Object originalContent = attributes.getValueAt(i, 1);
           final Object content = textController.getTransformedObjectNoFormattingNoThrow(node, attributes, originalContent);
           if (checkContent(content))
               return true;
       }
       return false;
   }
   
Purpose:
Traverse the attribute list of the specified node node to determine whether it contains an attribute that meets a specific condition. The condition is based on whether the attribute's name and value match the target attribute. Finally, call checkText(...) to verify whether the condition is satisfied.

Flow Graph:
[flow graph](./feature1Flow.png)

Calculations: 
Number of nodes: 10
Number of edges: 13
Cyclomatic complexity formula:
V(G) = number of edges – number of nodes + 2 = 13 – 10 + 2 = 5

Independent Paths:
1 → 2 → 3 → 4 → 5 → 2
Scenario: Attribute name is ANY, but checkText returns false (no match on name).
Expected: Loop continues to next attribute (or returns false if only one row).
1 → 2 → 3 → 6 → 5 → 2
Scenario: Attribute is not ANY, and does not equal the target attribute — entry skipped via continue.
Expected: Skips unmatched attribute row and continues loop; eventually returns false if no match found.
1 → 2 →  9 → 10
Scenario: Attribute list is empty, or all entries were skipped without any checkText being triggered.
Expected: No iterations are executed, or none result in return true — final result is false.
1 → 2 → 3 → 6 → 7 → 8 → 10
Scenario: Attribute equals target attribute, and the checkText on its value returns true.
Expected: Immediately returns true as the condition is satisfied.
1 → 2 → 3 → 6 → 7 → 9 → 10
Scenario: Attribute equals target attribute, but checkText on its value returns false.
Expected: This entry is examined but rejected → loop continues → if no other match, function returns false.

Test Cases:
Path1Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path1Test {
   @Test
   public void testPath1() {
       SimpleNode node = new SimpleNode();
       node.addAttribute("random", "no_match");
       AttributeContainsCondition cond = new AttributeContainsCondition("ANY", "MATCH");
       assertFalse(cond.checkNode(node));
   }
}

Path2Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path2Test {
   @Test
   public void testPath2() {
       SimpleNode node = new SimpleNode();
       node.addAttribute("other", "someValue");
       AttributeContainsCondition cond = new AttributeContainsCondition("targetAttr", "MATCH");
       assertFalse(cond.checkNode(node));
   }
}


Path3Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path3Test {
   @Test
   public void testPath3() {
       SimpleNode node = new SimpleNode();
       AttributeContainsCondition cond = new AttributeContainsCondition("targetAttr", "MATCH");
       assertFalse(cond.checkNode(node));
   }
}


Path4Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path4Test {
   @Test
   public void testPath4() {
       SimpleNode node = new SimpleNode();
       node.addAttribute("type", "this MATCHes!");
       AttributeContainsCondition cond = new AttributeContainsCondition("type", "MATCH");
       assertTrue(cond.checkNode(node));
   }
}


Path5Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path5Test {
   @Test
   public void testPath5() {
       SimpleNode node = new SimpleNode();
       node.addAttribute("type", "no match here");
       AttributeContainsCondition cond = new AttributeContainsCondition("type", "MATCH");
       assertFalse(cond.checkNode(node));
   }
}

Run Test-Cases:




Method/Function 2
Selected Method: 
freeplane/freeplane_plugin_script/src/main/java/org/freeplane/plugin/script/addons/ManageAddOnsDialog.java
	public ManageAddOnsDialog(final List<AddOnProperties> addOns) {
		super((Frame) UITools.getMenuComponent(), TextUtils.getText("ManageAddOnsAction.text"), true);
		// stolen from FileRevisionsDialog - no idea if actually needed
		if (getOwner() != null) {
			final Window[] ownedWindows = getOwner().getOwnedWindows();
			for (Window w : ownedWindows) {
				if (w.isVisible()) {
					w.toBack();
				}
			}
		}
		tabbedPane = new JTabbedPane();
		tabbedPane.setPreferredSize(getPreferredSizeForWindow());
		final ManageAddOnsPanel manageAddOnsPanel = new ManageAddOnsPanel(filterNonThemes(addOns));
		final ManageAddOnsPanel manageThemesPanel = new ManageAddOnsPanel(filterThemes(addOns));
		addOnInstallerPanel = new AddOnInstallerPanel(manageAddOnsPanel, manageThemesPanel);
		tabbedPane.addTab(getText("tab.install"), createIcon("/images/install_addons.svg"), addOnInstallerPanel,
		    getText("tab.install.tooltip"));
		tabbedPane.addTab(getText("tab.manage"), createIcon("/images/manage_addons.svg"), manageAddOnsPanel,
		    getText("tab.manage.tooltip"));
		tabbedPane.addTab(getText("tab.manage.themes"), createIcon("/images/manage_themes.svg"), manageThemesPanel,
		    getText("tab.manage.themes.tooltip"));
		getContentPane().add(tabbedPane, BorderLayout.CENTER);
		{
			JPanel buttonPane = new JPanel();
			buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));
			getContentPane().add(buttonPane, BorderLayout.SOUTH);
			{
				JButton closeButton = new JButton();
				LabelAndMnemonicSetter.setLabelAndMnemonic(closeButton, TextUtils.getRawText("close_btn"));
				closeButton.addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent e) {
						setVisible(false);
					}
				});
				buttonPane.add(closeButton);
			}
		}
		pack();
		setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
		UITools.addEscapeActionToDialog(this);
	}

Flow Graph:
Calculations: 
	Number of Nodes (N): 7
	Number of Edges (E): 10
	Connected Components (P): 1​
	Cyclomatic Complexity Formula:
	V(G) = E - N + 2P = 10 - 7 + 2*1 = 5 
Independent Paths:
	Path 1: Owner is null
	Flow: Start → Check if getOwner() != null → UI Setup → End
	Scenario: The dialog has no owner.
	Expected Behavior: The method skips the window iteration logic and proceeds directly to initialize the UI components.​
	Path 2: Owner exists, but ownedWindows is empty
	Flow: Start → Check if getOwner() != null → Retrieve ownedWindows → Loop over ownedWindows (no iterations) → UI Setup → End
	Scenario: The dialog has an owner, but there are no owned windows.
	Expected Behavior: The method retrieves an empty list of owned windows and proceeds to initialize the UI components without entering the loop.​
	Path 3: Owner exists, one ownedWindow is not visible
	Flow: Start → Check if getOwner() != null → Retrieve ownedWindows → Loop over ownedWindows → Check if w.isVisible() (false) → Continue loop → UI Setup → End
	Scenario: The dialog has an owner with one owned window that is not visible.
	Expected Behavior: The method checks the visibility of the window, finds it not visible, skips the w.toBack() call, and proceeds to initialize the UI components.​
	Path 4: Owner exists, one ownedWindow is visible
	Flow: Start → Check if getOwner() != null → Retrieve ownedWindows → Loop over ownedWindows → Check if w.isVisible() (true) → Execute w.toBack() → Continue loop → UI Setup → End
	Scenario: The dialog has an owner with one owned window that is visible.
	Expected Behavior: The method checks the visibility of the window, finds it visible, calls w.toBack() to send it to the back, and then proceeds to initialize the UI components.​
	Path 5: Owner exists, multiple ownedWindows with mixed visibility
	Flow: Start → Check if getOwner() != null → Retrieve ownedWindows → Loop over ownedWindows → For each w: Check if w.isVisible() → If true, execute w.toBack() → Continue loop → UI Setup → End
	Scenario: The dialog has an owner with multiple owned windows, some visible and some not.
	Expected Behavior: The method iterates over each owned window, sending the visible ones to the back using w.toBack(), and then proceeds to initialize the UI components.

Test Cases:
	Test Class 1: Owner is null
	import org.junit.jupiter.api.Test;
	import static org.junit.jupiter.api.Assertions.*;
	import java.util.Collections;
	public class ManageAddOnsDialogTest_NoOwner {
	    @Test
	    public void testConstructorWithNullOwner() {
		// Since getOwner() is null, the window iteration should be skipped.
		ManageAddOnsDialog dialog = new ManageAddOnsDialog(Collections.emptyList());
		assertNotNull(dialog);
		// Additional assertions can be added here to verify UI components if accessible.
	    }
	}

	 Test Class 2: Owner exists, but ownedWindows is empty
	import org.junit.jupiter.api.Test;
	import static org.junit.jupiter.api.Assertions.*;
	import java.awt.Frame;
	import java.util.Collections;
	public class ManageAddOnsDialogTest_OwnerNoOwnedWindows {
	    @Test
	    public void testConstructorWithOwnerNoOwnedWindows() {
		// Create a dummy Frame to act as the owner with no owned windows.
		Frame owner = new Frame();
		// Assuming UITools.getMenuComponent() returns this owner.
		// You may need to mock UITools.getMenuComponent() to return 'owner' if possible.

		ManageAddOnsDialog dialog = new ManageAddOnsDialog(Collections.emptyList());
		assertNotNull(dialog);
		// Additional assertions can be added here to verify UI components if accessible.
	    }
	}

	Test Class 3: Owner exists, one ownedWindow is not visible
	import org.junit.jupiter.api.Test;
	import static org.junit.jupiter.api.Assertions.*;
	import java.awt.Frame;
	import java.awt.Window;
	import java.util.Collections;
	public class ManageAddOnsDialogTest_OwnerOneOwnedWindowNotVisible {
	    @Test
	    public void testConstructorWithOneOwnedWindowNotVisible() {
		Frame owner = new Frame();
		Window ownedWindow = new Window(owner);
		ownedWindow.setVisible(false);
		// Assuming UITools.getMenuComponent() returns 'owner'.
		// You may need to mock UITools.getMenuComponent() to return 'owner' if possible.
		ManageAddOnsDialog dialog = new ManageAddOnsDialog(Collections.emptyList());
		assertNotNull(dialog);
		// Additional assertions can be added here to verify UI components if accessible.
	    }
	}

	 Test Class 4: Owner exists, one ownedWindow is visible
	import org.junit.jupiter.api.Test;
	import static org.junit.jupiter.api.Assertions.*;
	import java.awt.Frame;
	import java.awt.Window;
	import java.util.Collections;
	public class ManageAddOnsDialogTest_OwnerOneOwnedWindowVisible {
	    @Test
	    public void testConstructorWithOneOwnedWindowVisible() {
		Frame owner = new Frame();
		Window ownedWindow = new Window(owner);
		ownedWindow.setVisible(true);
		// Assuming UITools.getMenuComponent() returns 'owner'.
		// You may need to mock UITools.getMenuComponent() to return 'owner' if possible.

		ManageAddOnsDialog dialog = new ManageAddOnsDialog(Collections.emptyList());
		assertNotNull(dialog);
		// Additional assertions can be added here to verify UI components if accessible.
	    }
	}

	 Test Class 5: Owner exists, multiple ownedWindows with mixed visibility
	import org.junit.jupiter.api.Test;
	import static org.junit.jupiter.api.Assertions.*;
	import java.awt.Frame;
	import java.awt.Window;
	import java.util.Collections;
	public class ManageAddOnsDialogTest_OwnerMultipleOwnedWindowsMixedVisibility {
	    @Test
	    public void testConstructorWithMultipleOwnedWindowsMixedVisibility() {
		Frame owner = new Frame();
		Window visibleWindow = new Window(owner);
		visibleWindow.setVisible(true);
		Window invisibleWindow = new Window(owner);
		invisibleWindow.setVisible(false);
		// Assuming UITools.getMenuComponent() returns 'owner'.
		// You may need to mock UITools.getMenuComponent() to return 'owner' if possible.
		ManageAddOnsDialog dialog = new ManageAddOnsDialog(Collections.emptyList());
		assertNotNull(dialog);
		// Additional assertions can be added here to verify UI components if accessible.
	    }
	}

Run Test-Cases:

Method/Function 3
Selected Method: 
freeplane/src/main/java/org/freeplane/features/export/mindmapmode/ExportController.java
package org.freeplane.features.export.mindmapmode;

import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;

import javax.swing.filechooser.FileFilter;

import org.freeplane.core.extension.IExtension;
import org.freeplane.core.io.xml.XMLLocalParserFactory;
import org.freeplane.core.resources.ResourceController;
import org.freeplane.core.ui.components.UITools;
import org.freeplane.core.util.LogUtils;
import org.freeplane.core.util.TextUtils;
import org.freeplane.features.map.MapModel;
import org.freeplane.features.mode.Controller;
import org.freeplane.features.mode.ModeController;
import org.freeplane.n3.nanoxml.IXMLParser;
import org.freeplane.n3.nanoxml.IXMLReader;
import org.freeplane.n3.nanoxml.StdXMLReader;
import org.freeplane.n3.nanoxml.XMLElement;

/**
 * A registry of all XSLT scripts that are available to transform a .mm file into another format.
 * The XSLT file directories are scanned anew by each instance of this class to account for changes during uptime.
 * The filterMap maps descriptions onto a XSLT file. This enables multiple filters for one file extension.
 */
public class ExportController implements IExtension{
	/** a hash where the key is the file extension and the value the filename of
 	* the corresponding XSLT sheet. */
	final private HashMap<FileFilter, IExportEngine> mapExportEngines = new HashMap<FileFilter, IExportEngine>();
	final private ArrayList<FileFilter> mapExportFileFilters = new ArrayList<FileFilter>();

	final private HashMap<FileFilter, IExportEngine> branchExportEngines = new HashMap<FileFilter, IExportEngine>();
	final private ArrayList<FileFilter> branchExportFileFilters = new ArrayList<FileFilter>();
	private boolean fileFiltersSorted;

	public static void install(ExportController exportController) {
    	Controller.getCurrentModeController().addExtension(ExportController.class, exportController);
	}

	public ExportController(final String xmlDescriptorFile) {
    	final ModeController modeController = Controller.getCurrentModeController();
    	modeController.addAction(new ExportAction());
    	modeController.addAction(new ExportBranchesAction());

    	final ExportToHTML exportToHTML = new ExportToHTML();
    	addMapExportEngine(exportToHTML.getFileFilter(), exportToHTML);
    	final ExportBranchesToHTML exportBranchesToHTML = new ExportBranchesToHTML();
    	addBranchExportEngine(exportBranchesToHTML.getFileFilter(), exportBranchesToHTML);

    	final ExportToOoWriter exportToOoWriter = new ExportToOoWriter();

    	addMapExportEngine(exportToOoWriter.getFileFilter(), exportToOoWriter);
    	addBranchExportEngine(exportToOoWriter.getFileFilter(), exportToOoWriter);
    	createImageExporters();
    	createXSLTExportActions(xmlDescriptorFile);
    	new XsltExportEngineFactory().gatherXsltScripts(this);
    	fileFiltersSorted = false;
	}

	private void sortFileFilters() {
    	if (! fileFiltersSorted) {
        	fileFiltersSorted = true;
        	Comparator<FileFilter> fileFilterComparator = new Comparator<FileFilter>() {
            	public int compare(FileFilter f1, FileFilter f2) {
                	return f1.getDescription().compareToIgnoreCase(f2.getDescription());
            	}
        	};
        	Collections.sort(mapExportFileFilters, fileFilterComparator);
        	Collections.sort(branchExportFileFilters, fileFilterComparator);
    	}
	}

	public void createImageExporters() {
    	final ExportToImage pngExport = new ExportToImage("png","Portable Network Graphic (PNG)", BufferedImage.TYPE_INT_ARGB);
    	addMapExportEngine(pngExport.getFileFilter(), pngExport);
    	final ExportToImage jpgExport = new ExportToImage("jpg","Compressed image (JPEG)", BufferedImage.TYPE_INT_RGB);
    	addMapExportEngine(jpgExport.getFileFilter(), jpgExport);
	}

	private void createXSLTExportActions( final String xmlDescriptorFile) {
    	final URL resource = ResourceController.getResourceController().getResource(xmlDescriptorFile);
    	try (InputStream xmlDescriptorStream = resource.openStream()){
        	final IXMLParser parser = XMLLocalParserFactory.createLocalXMLParser();
        	final IXMLReader reader = new StdXMLReader(xmlDescriptorStream);
        	parser.setReader(reader);
        	final XMLElement xml = (XMLElement) parser.parse();
        	final Enumeration<XMLElement> actionDescriptors = xml.enumerateChildren();
        	while (actionDescriptors.hasMoreElements()) {
            	final XMLElement descriptor = actionDescriptors.nextElement();
            	final String name = descriptor.getAttribute("name", null);
            	final XMLElement xmlProperties = descriptor.getFirstChildNamed("properties");
            	final Properties properties = xmlProperties.getAttributes();
            	final ExportWithXSLT action = new ExportWithXSLT(name, properties);
            	FileFilter fileFilter = action.getFileFilter();
            	addMapExportEngine(fileFilter, action);
            	if(Boolean.parseBoolean(properties.getProperty("branch_export")))
                	addBranchExportEngine(fileFilter, action);
        	}
    	}
    	catch (final Exception e) {
        	LogUtils.severe(e);
    	}
	}

	public void addMapExportEngine(final FileFilter filter, final IExportEngine exporter) {
    	if (! mapExportEngines.values().contains(exporter))
    	{
        	mapExportFileFilters.add(filter);
        	mapExportEngines.put(filter, exporter);
        	fileFiltersSorted = false;
    	}
	}

	public void addBranchExportEngine(final FileFilter filter, final IExportEngine exporter) {
    	if (! branchExportEngines.values().contains(exporter))
    	{
        	branchExportFileFilters.add(filter);
        	branchExportEngines.put(filter, exporter);
        	fileFiltersSorted = false;
    	}
	}
	public HashMap<FileFilter, IExportEngine> getMapExportEngines() {
    	return mapExportEngines;
	}
	public HashMap<FileFilter, IExportEngine> getBranchExportEngines() {
    	return branchExportEngines;
	}

	public List<FileFilter> getMapExportFileFilters() {
    	sortFileFilters();
    	return mapExportFileFilters;
	}

	public List<FileFilter> getBranchExportFileFilters() {
    	sortFileFilters();
    	return branchExportFileFilters;
	}

	public static ExportController getContoller() {
    	return getController(Controller.getCurrentModeController());
	}

	public static ExportController getController(ModeController modeController) {
    	return modeController.getExtension(ExportController.class);
	}

	public boolean checkCurrentMap(MapModel map) {
    	if(map.equals(Controller.getCurrentController().getMap())){
        	return true;
    	}
    	UITools.errorMessage(TextUtils.getText("export_works_for_current_map_only"));
    	return false;
	}

	ExportDialog createMapExportDialog() {
    	return new ExportDialog(getMapExportFileFilters(), getMapExportEngines(), ExportDialog.EXPORT_MAP_TITLE);
	}

	ExportDialog createBranchExportDialog() {
    	return new ExportDialog(getBranchExportFileFilters(), getBranchExportEngines(), ExportDialog.EXPORT_BRANCHES_TITLE);
	}
}
Purpose: This class manages different export options for Freeplane. It loads and registers export engines (like HTML, image, or XSLT) based on file type and user settings.
Flow Graph:
[flow graph](./feature3Flow.png)
Calculations: 
Number of nodes: 10
Number of edges: 13
Cyclomatic complexity formula:
V(G) = number of edges – number of nodes + 2  
 	= 13 – 10 + 2  
 	= 5
Independent Paths:
Independent paths: 4
1. 1 → 2 → 3 → 4 → 5 → 6 → 7 → 11
Scenario:
 The XML file is read successfully, and all descriptors do not contain the branch_export property.
Expected:
 Only addMapExportEngine() is executed. The loop finishes without calling addBranchExportEngine(), and the method ends normally.
2. 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 5 → ... → 7 → 11
Scenario:
 The XML file is read successfully, and at least one descriptor has branch_export=true.
Expected:
 The if (branch_export == true) condition is true for at least one loop iteration. Both addMapExportEngine() and addBranchExportEngine() are called before continuing the loop. Ends after all descriptors are processed.
3. 1 → 2 → 3 → 10 → 11
Scenario:
 An exception occurs during file reading or XML parsing.
Expected:
 Control jumps to the catch block, and LogUtils.severe(e) is called to log the error. The method ends after logging.
4. 1 → 2 → 3 → 4 → 5 → 11
Scenario:
 The XML is valid but contains no <descriptor> elements.
Expected:
 The while (actionDescriptors.hasMoreElements()) condition is false immediately, and the loop is skipped entirely. The method ends without processing any actions.

Test Cases:
Path1Test.java
import org.junit.Test;
import static org.junit.Assert.*;

public class Path1Test {
	@Test
	public void testMissingDescriptorFile() {
    	try {
        	ExportController controller = new ExportController("non_existent.xml");
        	assertNotNull(controller.getMapExportEngines());
    	} catch (Exception e) {
        	fail("Should not crash even with invalid file.");
    	}
	}
}


Path2Test.java
import org.junit.Test;
import static org.junit.Assert.*;

public class Path2Test {
	@Test
	public void testValidDescriptorFile() {
    	ExportController controller = new ExportController("xslt/valid_export.xml");
    	assertNotNull(controller.getMapExportEngines());
	}
}

Path3Test.java
import org.junit.Test;
import static org.junit.Assert.*;

public class Path3Test {
	@Test
	public void testWithoutBranchExport() {
    	ExportController controller = new ExportController("xslt/no_branch_export.xml");
    	assertEquals(0, controller.getBranchExportEngines().size());
	}
}
Path4Test.java
import org.junit.Test;
import static org.junit.Assert.*;

public class Path4Test {
	@Test
	public void testWithBranchExport() {
    	ExportController controller = new ExportController("xslt/with_branch_export.xml");
    	assertTrue(controller.getBranchExportEngines().size() > 0);
	}
}

Run Test-Cases:
[test result](./feature3TestResult.PNG)
Method/Function 4
Selected Method: 
freeplane/freeplane/src/main/java/org/freeplane/features/attribute/AttributeBuilder.java

public Object createElement(final Object parent, final String tag, final XMLElement attributes) {
	if (tag.equals(AttributeBuilder.XML_NODE_ATTRIBUTE)
			|| tag.equals(AttributeBuilder.XML_NODE_REGISTERED_ATTRIBUTE_VALUE)) {
		return new AttributeProperties(parent);
	}
	if (tag.equals(AttributeBuilder.XML_NODE_REGISTERED_ATTRIBUTE_NAME)) {
		return new RegisteredAttributeProperties();
	}
	if (tag.equals(AttributeBuilder.XML_NODE_ATTRIBUTE_REGISTRY)) {
		return parent;
	}
	return null;
}

Purpose:
Determines what element is created according to the XML attributes tag.

Flow Graph:
[flow graph](./feature4Flow.png)

Calculations: 
Number of nodes: 9
Number of edges: 11
Cyclomatic complexity formula:
V(G)  =  number of edges – number of nodes + 2
 = 11 – 9 + 2
 = 4

Independent Paths:
Independent paths: 4
1,2,7,6
Scenario: tag for generation is XML_NODE_ATTRIBUTE or XML_NODE_REGISTERED_ATTRIBUTE_VALUE
Expected: Return a new AttributeProperties class with parent as argument. 

1,2,3,8,6
Scenario: tag for generation is XML_NODE_REGISTERED_ATTRIBUTE_NAME
Expected: Return a new RegisteredAttributeProperties class. 

1,2,3,4,9,6
Scenario: tag for generation is XML_NODE_ATTRIBUTE_REGISTRY
Expected: Return parent. 

1,2,3,4,5,6
Scenario: tag is not one of the above tags
Expected: Return null

Test Cases:
package org.freeplane.features.attribute;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import org.freeplane.features.attribute.AttributeBuilder.AttributeProperties;
import org.freeplane.features.attribute.AttributeBuilder.RegisteredAttributeProperties;
import org.freeplane.n3.nanoxml.XMLElement;
import org.junit.Test;


public class AttributeBuilderSpec {
    @Test
	public void createElementAttributeProperties() throws Exception {
        AttributeBuilder aBulid = new AttributeBuilder(null, null);
        Object result = aBulid.createElement(null, AttributeBuilder.XML_NODE_ATTRIBUTE, new XMLElement());

        assertTrue(result instanceof AttributeProperties);
	}

    @Test
	public void createElementRegisteredAttributeProperties() throws Exception {
        AttributeBuilder aBulid = new AttributeBuilder(null, null);
        Object result = aBulid.createElement(null, AttributeBuilder.XML_NODE_REGISTERED_ATTRIBUTE_NAME, new XMLElement());

        assertTrue(result instanceof RegisteredAttributeProperties);
	}

    @Test
	public void createElementParent() throws Exception {
        AttributeBuilder aBulid = new AttributeBuilder(null, null);
        Object result = aBulid.createElement(1, AttributeBuilder.XML_NODE_ATTRIBUTE_REGISTRY, new XMLElement());

        assertEquals(1, result);
	}

    @Test
	public void createElementNull() throws Exception {
        AttributeBuilder aBulid = new AttributeBuilder(null, null);
        Object result = aBulid.createElement(null, AttributeBuilder.XML_NODE_ATTRIBUTE_LAYOUT, new XMLElement());

        assertNull(result);
	}
}

[code file](./AttributeBuilderSpec.java)

Run Test-Cases:
[test result](./feature4TestResult.PNG)
(Used VScode’s java testing)

Method/Function 5
Selected Method: 
freeplane/src/main/java/org/freeplane/features/attribute/AttributeRegistry.java
public boolean exist(final String attributeName, final Object element) {
    final int index = indexOf(attributeName);
    if (index == -1) {
        return false;
    }
    final SortedComboBoxModel values = getElement(index).getValues();
    for (int i = 0; i < values.getSize(); i++) {
        if (element.equals(values.getElementAt(i))) {
            return true;
        }
    }
    return false;
}

Flow Graph:
[flow graph](./feature5Flow.png)

Calculations: 
Number of nodes: 9
Number of edges: 11
Cyclomatic complexity formula:
V(G) = number of edges – number of nodes + 2
= 11 – 9 + 2
= 4

Independent Paths:
1,2,3,9
Scenario: The attributeName does not exist in the elements collection (indexOf returns -1).
Expected: Returns false.
1,2,4,8,9
Scenario: The attributeName exists, but its values list is empty or contains no matching element.
Expected: Returns false.
1,2,4,5,6,9
Scenario: The attributeName exists, and the first value in its values list matches the element.
Expected: Returns true.
1,2,4,5,7,4
Scenario: The attributeName exists, and a matching element is found after several iterations in the values list.
Expected: Returns true.

Test Cases:
import org.junit.Test;
import static org.junit.Assert.*;


public class Path1Test {
    @Test
    public void testPath1() {
        AttributeRegistry registry = new AttributeRegistry();
        // Attribute "attr3" does not exist
        assertFalse(registry.exist("attr3", "val1"));
    }
}




import org.junit.Test;
import static org.junit.Assert.*;


public class Path2Test {
    @Test
    public void testPath2() {
        AttributeRegistry registry = new AttributeRegistry();
        // Add attribute "attr2" with no values
        registry.elements.add("attr2", new AttributeRegistryElement("attr2", new ArrayList<>()));
        assertFalse(registry.exist("attr2", "val1"));
    }
}


import org.junit.Test;
import static org.junit.Assert.*;
import java.util.Arrays;


public class Path3Test {
    @Test
    public void testPath3() {
        AttributeRegistry registry = new AttributeRegistry();
        // Add attribute "attr1" with values ["val1", "val2"]
        registry.elements.add("attr1", new AttributeRegistryElement("attr1", Arrays.asList("val1", "val2")));
        assertTrue(registry.exist("attr1", "val1"));
    }
}


import org.junit.Test;
import static org.junit.Assert.*;
import java.util.Arrays;


public class Path4Test {
    @Test
    public void testPath4() {
        AttributeRegistry registry = new AttributeRegistry();
        // Add attribute "attr1" with values ["val1", "val2"]
        registry.elements.add("attr1", new AttributeRegistryElement("attr1", Arrays.asList("val1", "val2")));
        assertTrue(registry.exist("attr1", "val2"));
    }
}

Run Test-Cases:
[test result](./feature5TestResult.PNG)
