Method/Function 1

Selected Method:
freeplane/src/main/java/org/freeplane/features/attribute/AttributeContainsCondition.java
public boolean checkNode(final NodeModel node) {
       final IAttributeTableModel attributes = NodeAttributeTableModel.getModel(node);
       final TextController textController = TextController.getController();
       for (int i = 0; i < attributes.getRowCount(); i++) {
           if(attribute.equals(AttributeConditionController.ANY_ATTRIBUTE_NAME_OR_VALUE_OBJECT)){
               if (checkContent(attributes.getValueAt(i, 0)))
                   return true;


           }
           else if(! attributes.getValueAt(i, 0).equals(attribute)) {
               continue;
           }
           final Object originalContent = attributes.getValueAt(i, 1);
           final Object content = textController.getTransformedObjectNoFormattingNoThrow(node, attributes, originalContent);
           if (checkContent(content))
               return true;
       }
       return false;
   }
   
Purpose:
Traverse the attribute list of the specified node node to determine whether it contains an attribute that meets a specific condition. The condition is based on whether the attribute's name and value match the target attribute. Finally, call checkText(...) to verify whether the condition is satisfied.

Flow Graph:
[flow graph](./feature1Flow.png)

Calculations: 
Number of nodes: 10
Number of edges: 13
Cyclomatic complexity formula:
V(G) = number of edges – number of nodes + 2 = 13 – 10 + 2 = 5

Independent Paths:
1 → 2 → 3 → 4 → 5 → 2
Scenario: Attribute name is ANY, but checkText returns false (no match on name).
Expected: Loop continues to next attribute (or returns false if only one row).
1 → 2 → 3 → 6 → 5 → 2
Scenario: Attribute is not ANY, and does not equal the target attribute — entry skipped via continue.
Expected: Skips unmatched attribute row and continues loop; eventually returns false if no match found.
1 → 2 →  9 → 10
Scenario: Attribute list is empty, or all entries were skipped without any checkText being triggered.
Expected: No iterations are executed, or none result in return true — final result is false.
1 → 2 → 3 → 6 → 7 → 8 → 10
Scenario: Attribute equals target attribute, and the checkText on its value returns true.
Expected: Immediately returns true as the condition is satisfied.
1 → 2 → 3 → 6 → 7 → 9 → 10
Scenario: Attribute equals target attribute, but checkText on its value returns false.
Expected: This entry is examined but rejected → loop continues → if no other match, function returns false.

Test Cases:
Path1Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path1Test {
   @Test
   public void testPath1() {
       SimpleNode node = new SimpleNode();
       node.addAttribute("random", "no_match");
       AttributeContainsCondition cond = new AttributeContainsCondition("ANY", "MATCH");
       assertFalse(cond.checkNode(node));
   }
}

Path2Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path2Test {
   @Test
   public void testPath2() {
       SimpleNode node = new SimpleNode();
       node.addAttribute("other", "someValue");
       AttributeContainsCondition cond = new AttributeContainsCondition("targetAttr", "MATCH");
       assertFalse(cond.checkNode(node));
   }
}


Path3Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path3Test {
   @Test
   public void testPath3() {
       SimpleNode node = new SimpleNode();
       AttributeContainsCondition cond = new AttributeContainsCondition("targetAttr", "MATCH");
       assertFalse(cond.checkNode(node));
   }
}


Path4Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path4Test {
   @Test
   public void testPath4() {
       SimpleNode node = new SimpleNode();
       node.addAttribute("type", "this MATCHes!");
       AttributeContainsCondition cond = new AttributeContainsCondition("type", "MATCH");
       assertTrue(cond.checkNode(node));
   }
}


Path5Test.java
import org.junit.Test;
import static org.junit.Assert.*;


public class Path5Test {
   @Test
   public void testPath5() {
       SimpleNode node = new SimpleNode();
       node.addAttribute("type", "no match here");
       AttributeContainsCondition cond = new AttributeContainsCondition("type", "MATCH");
       assertFalse(cond.checkNode(node));
   }
}

Run Test-Cases:




Method/Function 2
Selected Method: 
Flow Graph:
Calculations: 
Independent Paths:
Test Cases:
Run Test-Cases:

Method/Function 3
Selected Method: 
freeplane/src/main/java/org/freeplane/features/export/mindmapmode/ExportController.java
package org.freeplane.features.export.mindmapmode;

import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;

import javax.swing.filechooser.FileFilter;

import org.freeplane.core.extension.IExtension;
import org.freeplane.core.io.xml.XMLLocalParserFactory;
import org.freeplane.core.resources.ResourceController;
import org.freeplane.core.ui.components.UITools;
import org.freeplane.core.util.LogUtils;
import org.freeplane.core.util.TextUtils;
import org.freeplane.features.map.MapModel;
import org.freeplane.features.mode.Controller;
import org.freeplane.features.mode.ModeController;
import org.freeplane.n3.nanoxml.IXMLParser;
import org.freeplane.n3.nanoxml.IXMLReader;
import org.freeplane.n3.nanoxml.StdXMLReader;
import org.freeplane.n3.nanoxml.XMLElement;

/**
 * A registry of all XSLT scripts that are available to transform a .mm file into another format.
 * The XSLT file directories are scanned anew by each instance of this class to account for changes during uptime.
 * The filterMap maps descriptions onto a XSLT file. This enables multiple filters for one file extension.
 */
public class ExportController implements IExtension{
	/** a hash where the key is the file extension and the value the filename of
 	* the corresponding XSLT sheet. */
	final private HashMap<FileFilter, IExportEngine> mapExportEngines = new HashMap<FileFilter, IExportEngine>();
	final private ArrayList<FileFilter> mapExportFileFilters = new ArrayList<FileFilter>();

	final private HashMap<FileFilter, IExportEngine> branchExportEngines = new HashMap<FileFilter, IExportEngine>();
	final private ArrayList<FileFilter> branchExportFileFilters = new ArrayList<FileFilter>();
	private boolean fileFiltersSorted;

	public static void install(ExportController exportController) {
    	Controller.getCurrentModeController().addExtension(ExportController.class, exportController);
	}

	public ExportController(final String xmlDescriptorFile) {
    	final ModeController modeController = Controller.getCurrentModeController();
    	modeController.addAction(new ExportAction());
    	modeController.addAction(new ExportBranchesAction());

    	final ExportToHTML exportToHTML = new ExportToHTML();
    	addMapExportEngine(exportToHTML.getFileFilter(), exportToHTML);
    	final ExportBranchesToHTML exportBranchesToHTML = new ExportBranchesToHTML();
    	addBranchExportEngine(exportBranchesToHTML.getFileFilter(), exportBranchesToHTML);

    	final ExportToOoWriter exportToOoWriter = new ExportToOoWriter();

    	addMapExportEngine(exportToOoWriter.getFileFilter(), exportToOoWriter);
    	addBranchExportEngine(exportToOoWriter.getFileFilter(), exportToOoWriter);
    	createImageExporters();
    	createXSLTExportActions(xmlDescriptorFile);
    	new XsltExportEngineFactory().gatherXsltScripts(this);
    	fileFiltersSorted = false;
	}

	private void sortFileFilters() {
    	if (! fileFiltersSorted) {
        	fileFiltersSorted = true;
        	Comparator<FileFilter> fileFilterComparator = new Comparator<FileFilter>() {
            	public int compare(FileFilter f1, FileFilter f2) {
                	return f1.getDescription().compareToIgnoreCase(f2.getDescription());
            	}
        	};
        	Collections.sort(mapExportFileFilters, fileFilterComparator);
        	Collections.sort(branchExportFileFilters, fileFilterComparator);
    	}
	}

	public void createImageExporters() {
    	final ExportToImage pngExport = new ExportToImage("png","Portable Network Graphic (PNG)", BufferedImage.TYPE_INT_ARGB);
    	addMapExportEngine(pngExport.getFileFilter(), pngExport);
    	final ExportToImage jpgExport = new ExportToImage("jpg","Compressed image (JPEG)", BufferedImage.TYPE_INT_RGB);
    	addMapExportEngine(jpgExport.getFileFilter(), jpgExport);
	}

	private void createXSLTExportActions( final String xmlDescriptorFile) {
    	final URL resource = ResourceController.getResourceController().getResource(xmlDescriptorFile);
    	try (InputStream xmlDescriptorStream = resource.openStream()){
        	final IXMLParser parser = XMLLocalParserFactory.createLocalXMLParser();
        	final IXMLReader reader = new StdXMLReader(xmlDescriptorStream);
        	parser.setReader(reader);
        	final XMLElement xml = (XMLElement) parser.parse();
        	final Enumeration<XMLElement> actionDescriptors = xml.enumerateChildren();
        	while (actionDescriptors.hasMoreElements()) {
            	final XMLElement descriptor = actionDescriptors.nextElement();
            	final String name = descriptor.getAttribute("name", null);
            	final XMLElement xmlProperties = descriptor.getFirstChildNamed("properties");
            	final Properties properties = xmlProperties.getAttributes();
            	final ExportWithXSLT action = new ExportWithXSLT(name, properties);
            	FileFilter fileFilter = action.getFileFilter();
            	addMapExportEngine(fileFilter, action);
            	if(Boolean.parseBoolean(properties.getProperty("branch_export")))
                	addBranchExportEngine(fileFilter, action);
        	}
    	}
    	catch (final Exception e) {
        	LogUtils.severe(e);
    	}
	}

	public void addMapExportEngine(final FileFilter filter, final IExportEngine exporter) {
    	if (! mapExportEngines.values().contains(exporter))
    	{
        	mapExportFileFilters.add(filter);
        	mapExportEngines.put(filter, exporter);
        	fileFiltersSorted = false;
    	}
	}

	public void addBranchExportEngine(final FileFilter filter, final IExportEngine exporter) {
    	if (! branchExportEngines.values().contains(exporter))
    	{
        	branchExportFileFilters.add(filter);
        	branchExportEngines.put(filter, exporter);
        	fileFiltersSorted = false;
    	}
	}
	public HashMap<FileFilter, IExportEngine> getMapExportEngines() {
    	return mapExportEngines;
	}
	public HashMap<FileFilter, IExportEngine> getBranchExportEngines() {
    	return branchExportEngines;
	}

	public List<FileFilter> getMapExportFileFilters() {
    	sortFileFilters();
    	return mapExportFileFilters;
	}

	public List<FileFilter> getBranchExportFileFilters() {
    	sortFileFilters();
    	return branchExportFileFilters;
	}

	public static ExportController getContoller() {
    	return getController(Controller.getCurrentModeController());
	}

	public static ExportController getController(ModeController modeController) {
    	return modeController.getExtension(ExportController.class);
	}

	public boolean checkCurrentMap(MapModel map) {
    	if(map.equals(Controller.getCurrentController().getMap())){
        	return true;
    	}
    	UITools.errorMessage(TextUtils.getText("export_works_for_current_map_only"));
    	return false;
	}

	ExportDialog createMapExportDialog() {
    	return new ExportDialog(getMapExportFileFilters(), getMapExportEngines(), ExportDialog.EXPORT_MAP_TITLE);
	}

	ExportDialog createBranchExportDialog() {
    	return new ExportDialog(getBranchExportFileFilters(), getBranchExportEngines(), ExportDialog.EXPORT_BRANCHES_TITLE);
	}
}
Purpose: This class manages different export options for Freeplane. It loads and registers export engines (like HTML, image, or XSLT) based on file type and user settings.
Flow Graph:
[flow graph](./feature3Flow.png)
Calculations: 
Number of nodes: 10
Number of edges: 13
Cyclomatic complexity formula:
V(G) = number of edges – number of nodes + 2  
 	= 13 – 10 + 2  
 	= 5
Independent Paths:
Independent paths: 4
1. 1 → 2 → 3 → 4 → 5 → 6 → 7 → 11
Scenario:
 The XML file is read successfully, and all descriptors do not contain the branch_export property.
Expected:
 Only addMapExportEngine() is executed. The loop finishes without calling addBranchExportEngine(), and the method ends normally.
2. 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 5 → ... → 7 → 11
Scenario:
 The XML file is read successfully, and at least one descriptor has branch_export=true.
Expected:
 The if (branch_export == true) condition is true for at least one loop iteration. Both addMapExportEngine() and addBranchExportEngine() are called before continuing the loop. Ends after all descriptors are processed.
3. 1 → 2 → 3 → 10 → 11
Scenario:
 An exception occurs during file reading or XML parsing.
Expected:
 Control jumps to the catch block, and LogUtils.severe(e) is called to log the error. The method ends after logging.
4. 1 → 2 → 3 → 4 → 5 → 11
Scenario:
 The XML is valid but contains no <descriptor> elements.
Expected:
 The while (actionDescriptors.hasMoreElements()) condition is false immediately, and the loop is skipped entirely. The method ends without processing any actions.

Test Cases:
Path1Test.java
import org.junit.Test;
import static org.junit.Assert.*;

public class Path1Test {
	@Test
	public void testMissingDescriptorFile() {
    	try {
        	ExportController controller = new ExportController("non_existent.xml");
        	assertNotNull(controller.getMapExportEngines());
    	} catch (Exception e) {
        	fail("Should not crash even with invalid file.");
    	}
	}
}


Path2Test.java
import org.junit.Test;
import static org.junit.Assert.*;

public class Path2Test {
	@Test
	public void testValidDescriptorFile() {
    	ExportController controller = new ExportController("xslt/valid_export.xml");
    	assertNotNull(controller.getMapExportEngines());
	}
}

Path3Test.java
import org.junit.Test;
import static org.junit.Assert.*;

public class Path3Test {
	@Test
	public void testWithoutBranchExport() {
    	ExportController controller = new ExportController("xslt/no_branch_export.xml");
    	assertEquals(0, controller.getBranchExportEngines().size());
	}
}
Path4Test.java
import org.junit.Test;
import static org.junit.Assert.*;

public class Path4Test {
	@Test
	public void testWithBranchExport() {
    	ExportController controller = new ExportController("xslt/with_branch_export.xml");
    	assertTrue(controller.getBranchExportEngines().size() > 0);
	}
}

Run Test-Cases:
[test result](./feature3TestResult.PNG)
Method/Function 4
Selected Method: 
freeplane/freeplane/src/main/java/org/freeplane/features/attribute/AttributeBuilder.java

public Object createElement(final Object parent, final String tag, final XMLElement attributes) {
	if (tag.equals(AttributeBuilder.XML_NODE_ATTRIBUTE)
			|| tag.equals(AttributeBuilder.XML_NODE_REGISTERED_ATTRIBUTE_VALUE)) {
		return new AttributeProperties(parent);
	}
	if (tag.equals(AttributeBuilder.XML_NODE_REGISTERED_ATTRIBUTE_NAME)) {
		return new RegisteredAttributeProperties();
	}
	if (tag.equals(AttributeBuilder.XML_NODE_ATTRIBUTE_REGISTRY)) {
		return parent;
	}
	return null;
}

Purpose:
Determines what element is created according to the XML attributes tag.

Flow Graph:
[flow graph](./feature4Flow.png)

Calculations: 
Number of nodes: 9
Number of edges: 11
Cyclomatic complexity formula:
V(G)  =  number of edges – number of nodes + 2
 = 11 – 9 + 2
 = 4

Independent Paths:
Independent paths: 4
1,2,7,6
Scenario: tag for generation is XML_NODE_ATTRIBUTE or XML_NODE_REGISTERED_ATTRIBUTE_VALUE
Expected: Return a new AttributeProperties class with parent as argument. 

1,2,3,8,6
Scenario: tag for generation is XML_NODE_REGISTERED_ATTRIBUTE_NAME
Expected: Return a new RegisteredAttributeProperties class. 

1,2,3,4,9,6
Scenario: tag for generation is XML_NODE_ATTRIBUTE_REGISTRY
Expected: Return parent. 

1,2,3,4,5,6
Scenario: tag is not one of the above tags
Expected: Return null

Test Cases:
package org.freeplane.features.attribute;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import org.freeplane.features.attribute.AttributeBuilder.AttributeProperties;
import org.freeplane.features.attribute.AttributeBuilder.RegisteredAttributeProperties;
import org.freeplane.n3.nanoxml.XMLElement;
import org.junit.Test;


public class AttributeBuilderSpec {
    @Test
	public void createElementAttributeProperties() throws Exception {
        AttributeBuilder aBulid = new AttributeBuilder(null, null);
        Object result = aBulid.createElement(null, AttributeBuilder.XML_NODE_ATTRIBUTE, new XMLElement());

        assertTrue(result instanceof AttributeProperties);
	}

    @Test
	public void createElementRegisteredAttributeProperties() throws Exception {
        AttributeBuilder aBulid = new AttributeBuilder(null, null);
        Object result = aBulid.createElement(null, AttributeBuilder.XML_NODE_REGISTERED_ATTRIBUTE_NAME, new XMLElement());

        assertTrue(result instanceof RegisteredAttributeProperties);
	}

    @Test
	public void createElementParent() throws Exception {
        AttributeBuilder aBulid = new AttributeBuilder(null, null);
        Object result = aBulid.createElement(1, AttributeBuilder.XML_NODE_ATTRIBUTE_REGISTRY, new XMLElement());

        assertEquals(1, result);
	}

    @Test
	public void createElementNull() throws Exception {
        AttributeBuilder aBulid = new AttributeBuilder(null, null);
        Object result = aBulid.createElement(null, AttributeBuilder.XML_NODE_ATTRIBUTE_LAYOUT, new XMLElement());

        assertNull(result);
	}
}

[code file](./AttributeBuilderSpec.java)

Run Test-Cases:
[test result](./feature4TestResult.PNG)
(Used VScode’s java testing)

Method/Function 5
Selected Method: 
Flow Graph:
Calculations: 
Independent Paths:
Test Cases:
Run Test-Cases:
