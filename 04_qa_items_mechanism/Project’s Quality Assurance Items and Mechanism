                            Project's_QA_Items_Mechanism   
Part 1
1. The three functionalities are clearly described from what the user does with the
product.
1）Dynamic Scripting & Automation
   Description:Enables users to extend and automate Freeplane’s behavior through custom scripts (e.g. Groovy), allowing them to modify node properties, perform calculations, and even add new features without waiting for official releases.
   User Action / Engagement:Users write or import scripts via the built-in script editor or external files to automate tasks, customize node behavior, or integrate add-ons.
   Example:Write scripts to traverse nodes, filter keywords, modify styles, and export, avoiding manual processing of hundreds of nodes.
2)Conditional Formatting & Data Recognition
  Description:Provides users with the ability to set rules that automatically adjust node appearance (e.g. color, icons) or compute values (using formulas) based on the node’s content. 
              This goes beyond manual formatting by making maps visually responsive to their data.
  User Action / Engagement:Users define conditions or formulas—either via the user interface or scripting—that trigger style changes or automatic recalculations when specific criteria are met.
  Example:Set the rule to "Node contains' # key 'becomes blue + bold", and the system automatically identifies urls as hyperlinks.
3)Advanced Navigation & Iterative Filtering
  Description:Offers powerful tools for searching, filtering, and iterating over nodes in large, complex maps.
              This functionality helps users focus on relevant information and navigate their maps more efficiently, even as maps grow in size and complexity.
  User Action / Engagement:Users engage with built-in search and filtering features (or use scripted closures) to traverse and display only the nodes that match defined criteria.
  Example:Enter "Manager A" filtering results, superimpose date conditions, and finally locate 3 key nodes.
2. The figure contains the main components of the project (not more than 10) and
the relations among them.
![components](IMG_6801-1.jpg)
3. The list contains the most important data structures of the product (not more
than 10) and their relationship.





Part 2
4. Review and Suggestion on three functionalities.
   1)Dynamic Scripting & Automation
     Purpose and Value:Scripts (such as Groovy) and automation tools help users batch process repetitive tasks (such as node modification and data export), reduce manual operation costs, and improve the efficiency of complex project management or knowledge collation.
     User benefit:1)Efficient processing of large-scale data: For example, researchers can write scripts to automatically extract literature keywords and generate structured reports, avoiding the need to manually organize hundreds of nodes.
                  2)Custom workflow: developers can through the plug-in extension functions (such as synchronous external data integration API), realize the personalized demand.
     Suggestion:1)Lower scripting barriers: Provide a visual script generator or preset common script templates (such as automatic Gantt chart generation) for non-technical users.
                2)Enhanced error warning: When a script fails to be executed, clearly mark the location of the error node and the cause, reducing the debugging time.
   2)Conditional Formatting & Data Recognition
     Purpose and Value:Dynamically adjust node styles (such as colors and ICONS) based on preset rules, and automatically identify data (such as dates and links), helping users quickly locate key information and improving information readability.
     User benefit:1)Visual priority management: Users can set "overdue task nodes turn red" to visually track project risks.
                  2)Automated data classification: When users organize notes, the software automatically recognizes reference links and adds hyperlink ICONS.
     Suggestion:1)Expanded data type recognition: Automatic identification and tagging of more structured data, such as email addresses and phone numbers.
                2)Add dynamic rule templates: Common rule combinations for scenarios such as Project Management and Study Notes are preset to reduce user configuration time.
   3)Advanced Navigation & Iterative Filtering
     Purpose and Value:By means of multi-layered condition screening (such as combination of keywords, dates and attributes) and the quick jump function, it helps users precisely locate the target nodes in complex diagrams, avoiding information overload.
     User benefit:1)Quickly focus on key contents: Researchers can first filter out "2025 literature", then add the "Unread" tag, and quickly narrow down the search scope.
                  2)Smoothly integrate complex diagram operations: Through shortcut keys and hierarchical expansion/collapse, users can quickly navigate through diagrams with numerous branches, such as directly locating detailed explanations of a certain sub-task from the project overview, 
                                                                   reducing the time spent on mouse scrolling and manual hierarchical expansion.
     Suggestion:1)Enhance cross-branch navigation: Add a "Jump to Associated Node" shortcut key to address the efficiency issue of jumping to deeply nested nodes.
                2)Optimize filtering of historical records: Allow users to save frequently used filtering combinations (such as "To-Do Tasks for This Week"), and enable one-click reuse.
5. Discussion on figure.
Component Name             Purpose / Description                        Interactions / Relations
(1). User Interface (UI) Module
Presents the mind map and supports user interaction (such as dragging nodes, modifying text, adjusting layout, etc.).
Processer user input and displays data from the Mind Map Data Model; 
Sends commands to the Core Controller; 
Adapts based on user settings from the Preferences Manager.
(2). Mind Map Data Model
​Manage the structure of the mind map, including core logic such as nodes, links and attributes..
Updated by the Core Controller and Command Manager; Accessed by the UI for display and by the Scripting Engine to manipulate map data.
(3). Core Controller & Workflow Manager
Coordinates the overall behavior of the application, processes user commands, manages workflow, and organizes interactions between subsystems. ​
Serves as the central hub that connects the UI, Data Model, Command Manager, and Scripting Engine; integrates settings from the Preferences Manager.
(4). Command Manager & Undo/Redo System
Track user actions and changes, and provide undo/redo functionality to ensure users can safely try and revert changes.
Monitors and records changes made by the Core Controller on the Data Model; works with the UI to trigger undo/redo actions when requested by the user.
(5). Scripting Engine & Extension API
Provides dynamic scripting support (e.g. using Groovy) to enable users to automate tasks, customize behavior, and extend functionality.
Allows scripts to interact with the Data Model, UI, and Core Controller; forms the basis for user-developed plugins and add‑ons.
(6). File Management Module
Responsible for saving, loading and exporting mind map files, supporting multiple formats (such as .mm, .html, .xml).
Reads from and writes to the Mind Map Data Model; is triggered by UI actions (e.g. “Save” or “Export”) and coordinated by the Core Controller.
(7). Plugin Framework
Allows users to extend Freeplane's functionality, making it highly customizable and extensible.
Integrates with the Core Controller and Scripting Engine to add or modify functionality; can extend UI elements; accesses configuration from the Preferences Manager.
(8). Configuration & Preferences Manager
​Manage system settings, user preferences, and other configuration data to control the overall behavior of the application.
Feeds configuration data to the UI, Core Controller, and Plugin Framework; ensures that customizations and user settings are applied across the system.



6. Discussion on the list of most important data structures.

7. QA Mechanism Documentation (Please see page 2 for details)
a. Three Defects:
Performance Degradation:
Description: Scripts or filters cause UI freezes or crashes when handling large mind maps (>10,000 nodes), degrading user experience due to Freeplane’s Java Swing architecture and computational overhead.
Risk: Users abandon Freeplane for slow performance on complex projects.
UI State Corruption:
Description: Script errors or interrupted operations (e.g., crashes) leave the mind map in an inconsistent state, such as unsaved changes or broken hyperlinks, due to unhandled exceptions in MapModel or NodeModel.
Risk: Data loss or usability issues frustrate users, eroding trust.
Filtering Inaccuracies:
Description: Advanced filters return incomplete or irrelevant nodes (e.g., missing partial keyword matches), stemming from potential flaws in FilterController logic for complex queries.
Risk: Users cannot reliably navigate or manage large maps, reducing functionality.

b. Training:
Performance Degradation:
Train contributors on Java Swing optimization techniques (e.g., minimizing repaint calls, using buffered rendering) and profiling tools like VisualVM to identify bottlenecks in real-time. Include sessions on handling large datasets efficiently, focusing on Freeplane’s event-driven UI model.
UI State Corruption:
Educate developers on exception handling best practices in Java (e.g., try-catch blocks around script execution) and Freeplane’s autosave/recovery mechanisms (MapModel). Use case studies of past crashes to highlight state preservation techniques.
Filtering Inaccuracies:
Train team members on Freeplane’s filtering system (FilterController, FilterCondition), emphasizing regex and attribute-based query logic. Simulate edge cases (e.g., partial matches, case sensitivity) to ensure understanding of accurate filter implementation.

c. Policies:
Performance Degradation:
Enforce a coding standard requiring performance impact assessments for new features or scripts (e.g., “No pull request merged without profiling data for >1,000 nodes”). Mandate lightweight algorithms for UI updates, aligned with IEEE 730-2014’s quality attribute focus.
UI State Corruption:
Require mandatory peer reviews for script-related code, with a checklist ensuring exception handling and state consistency (e.g., “Does this preserve MapModel integrity on failure?”). Establish a versioning policy for autosave files to track state changes.
Filtering Inaccuracies:
Mandate documentation of filter logic in pull requests and a policy for regression testing all filter conditions before release. Align with best practices by requiring filter specs to be reviewed against user requirements.

d. Tests:
Performance Degradation:
Implement automated performance tests in the GitHub Actions CI pipeline using JUnit, simulating large maps (e.g., 10,000 nodes with scripts/filters) and measuring latency (e.g., <3 seconds threshold). Add stress tests with varying node counts and profiling to catch freezes or crashes.
UI State Corruption:
Develop unit tests for script execution (e.g., test_script_failure_preserves_state() in ScriptingEngine) and integration tests to verify autosave triggers after interruptions. Include fuzz testing to simulate erratic script inputs and validate state recovery.
Filtering Inaccuracies:
Create unit tests for FilterCondition (e.g., test_partial_keyword_match()) and integration tests comparing filter outputs to expected node sets (e.g., golden master files). Add system tests to validate end-to-end filtering on sample maps with complex queries.

e. Measures:
Performance Degradation:
Monitor KPIs like average rendering time for 1,000+ node maps (via test logs) and user-reported lag incidents (GitHub Issues). Set a threshold (e.g., >3 seconds triggers review) and track improvement trends post-optimization.
UI State Corruption:
Measure defect rates for crash-related Issues and user feedback on data loss (via Discussions/X). Track autosave success rate (e.g., % of recoveries completed) to refine recovery mechanisms.
Filtering Inaccuracies:
Monitor filter-related bug reports (GitHub Issues) and customer satisfaction scores from Discussions (e.g., “Did filters work as expected?”). Measure accuracy rates in test suites (e.g., % of correct node matches).

QA Mechanism Details
Documentation:
• Regularly reviewed & updated to reflect the current state of
the product.
• Prevents “out-of-date” instructions that might introduce new
defects.
Training:
• Train team members on product design,
manufacturing/implementation processes, and safety
standards.
• Ensures everyone has the knowledge to identify & address
potential defects early.
Policies:
• Summarize the written guidelines governing the project’s
design, coding standards, and manufacturing processes.
• Keep them updated so they align with current best practices
and regulatory requirements.
Tests:
• Conduct rigorous testing (design validation, manufacturing
validation, product verification).
• Catch potential defects before release. May include unit tests,
integration tests, system tests, etc.
Measures:
• Monitor and measure key performance indicators (defect rates,
customer satisfaction, regulatory compliance).
• Use these metrics to refine and improve the QA process
continuously.

