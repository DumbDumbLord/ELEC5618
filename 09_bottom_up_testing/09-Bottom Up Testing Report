Class 1
Selected Class
    NodeModel.java

    Directory:
    freeplane\src\main\java\org\freeplane\features\map\NodeModel.java
    Test Suite
    1. Ensure dependencies are present in build.gradle:
    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.3'
    testImplementation 'org.mockito:mockito-core:5.2.0'

    test {
        useJUnitPlatform()
    }

    2. Place the test file at:	freeplane/freeplane/src/test/java/org/freeplane/features/map/NodeModelClassTest.java

    3. Run tests from the project root or module directory:
    cd freeplane/freeplane
    gradle test

    or to run only this test class:
    gradle test --tests org.freeplane.features.map.NodeModelClassTest

    4. View the test report: Open freeplane/freeplane/build/reports/tests/test/index.html in your browser to see the results.

    Tests:
    testSetAndGetText
    Verifies that the setText and getText methods correctly set and retrieve the node's text content.

    testInsertAndGetChild
    Checks that inserting a child node increases the parent's child count, allows retrieval by index, and sets the correct parent reference for the child.

    testFoldedState
    Tests the isFolded and setFolded methods to ensure the node's folded (collapsed/expanded) state can be toggled and queried accurately.

    testSetAndGetSide
    Ensures that the node's side (e.g., TOP_OR_LEFT) can be set and retrieved using setSide and getSide.

    testSetAndGetUserObject
    Verifies that an arbitrary user object can be attached to the node and retrieved with setUserObject and getUserObject.

    testChildrenListUnmodifiable
    Confirms that the list returned by getChildren is unmodifiable, i.e., attempts to add elements throw an exception.

    testIsLeaf
    Checks if the node correctly reports being a leaf (no children) and updates this status after a child is inserted.

    testSetAndGetXmlText
    Tests setting and retrieving the node's XML text representation, ensuring it is stored and returned in the expected format.

    testDepth
    Verifies that the depth method accurately reports the node's depth in the tree structure (root = 0, child = 1, grandchild = 2, etc.).
Test Outcomes
    pic
Additional Classes
    MapModel
    (freeplane\src\main\java\org\freeplane\features\map\MapModel.java)
    Manages the structure and data of the mind map, storing and organizing NodeModel objects in a tree. It provides methods for adding, removing, and accessing nodes, and notifies listeners about changes to nodes or the map.

    MapController
    (freeplane\src\main\java\org\freeplane\features\map\MapController.java)
    Handles user actions and logic for the mind map. It operates on NodeModel objects by selecting, folding/unfolding, sorting, and updating nodes. It coordinates changes between the UI and the underlying MapModel, ensuring that operations on nodes are reflected in both the data and the interface.
Bottom-Up Testing
    testInsertNodeAndGetChild:
      Verifies that inserting a child node into a parent updates the parent's child count and allows correct retrieval of the child.
    testMapControllerSelect:
      Ensures that the select method of MapController can be called with a NodeModel and that the call is properly registered (using Mockito verification).
    testSortNodesByDepth:
      Demonstrates how to call the sortNodesByDepth method on a list of nodes. (Note: The actual sorting logic is not tested here since a real MapController object is not used.)
    
    pic

Class 2
Class 2
Selected Class
MapModel.java
Directory:
freeplane/src/main/java/org/freeplane/features/map/MapModel.java
Test Suite
1. Ensure dependencies are present in build.gradle（freeplane/build.gradle）:
testImplementation 'junit:junit:4.13.2'
testImplementation 'org.mockito:mockito-core:3.12.4'
testImplementation 'org.assertj:assertj-core:3.26.0'
2. Place the test file at:	freeplane/src/test/java/org/freeplane/features/map/MapModelSpec.java

3. Run the tests:
./gradlew :freeplane:test --tests org.freeplane.features.map.MapModelSpec

4. View the test report: Open freeplane/build/reports/tests/test/index.html in your browser to see the results.

Tests:
shouldCreateMapAndSetRootNode
Verifies that a root node can be created, assigned to a MapModel, and later retrieved correctly using getRootNode().
shouldInsertChildNodesAndRetrieve
Checks that child nodes can be inserted into a root node, retrieved by index, and that they are correctly registered and accessible using getNodeForID().
shouldSimulateFullMapCreation
Simulates the creation of a multi-level node hierarchy (root → childA → childB) and confirms proper parent-child relationships and node registration.
shouldSetAndGetRootNode
Tests MapModel.setRoot() and getRootNode() methods to ensure correct root node assignment and retrieval.
shouldRegisterNodeAndFindById
Verifies that a node with a specific ID can be registered using registryNode() and retrieved using getNodeForID().
shouldSetAndGetReadOnlyFlag
Tests that MapModel.setReadOnly() accurately updates the read-only flag, and isReadOnly() reflects the correct state.
shouldSetAndGetURL
Ensures that MapModel.setURL() correctly sets the URL, and both getURL() and getTitle() return the expected values.
shouldRegisterNodesRecursively
Checks that registryNodeRecursive() properly registers a node and all its children, allowing retrieval by ID for any node in the subtree.
shouldSetAndCheckSavedStatusValidates the save state tracking by toggling 
setSaved(true/false) and confirming the result through isSaved().
shouldAddAndRemoveMapChangeListener
Ensures that a map change listener can be added and removed from the MapModel without error (functional verification via control flow).
shouldAddAndRemoveExtensions
Tests the MapModel extension system by adding a dummy extension, verifying presence with containsExtension(), and removing it successfully with removeExtension().
Test Outcomes
Additional Classes
NodeModel.java(src/main/java/org/freeplane/features/map/NodeModel.java)
MapController.java(src/main/java/org/freeplane/features/map/MapController.java)
Bottom-Up Testing
shouldCreateMapAndSetRootNode
Verifies that a NodeModel can be created, assigned as the root of a MapModel, and later retrieved using getRootNode(). It also checks that the node’s ID is preserved correctly.
@Test
   public void shouldCreateMapAndSetRootNode() {
       root = new NodeModel(map);
       root.setID("rootNode");
       map.setRoot(root);


       assertSame(root, map.getRootNode());
       assertEquals("rootNode", map.getRootNode().getID());
   }
shouldInsertChildNodesAndRetrieve
Tests the ability to insert multiple child nodes into the root node. It verifies that the children are retrievable by index, and that their IDs are correctly registered and retrievable via getNodeForID().
@Test
   public void shouldInsertChildNodesAndRetrieve() {
       root = new NodeModel(map);
       map.setRoot(root);


       NodeModel child1 = new NodeModel(map);
       child1.setID("child1");
       root.insert(child1);


       NodeModel child2 = new NodeModel(map);
       child2.setID("child2");
       root.insert(child2);


       map.registryNode(child1);
       map.registryNode(child2);


       assertEquals(2, root.getChildCount());
       assertSame(child1, root.getChildAt(0));
       assertSame(child2, root.getChildAt(1));
       assertSame(child1, map.getNodeForID("child1"));
       assertSame(child2, map.getNodeForID("child2"));
   }
shouldSimulateFullMapCreation
Simulates a nested node hierarchy (root → childA → childB) and ensures that the structure is built correctly. It validates that child nodes can be inserted at deeper levels and still be registered and accessed properly via their unique IDs.
@Test
   public void shouldSimulateFullMapCreation() {
       root = new NodeModel(map);
       root.setID("root123");
       map.setRoot(root);


       NodeModel childA = new NodeModel(map);
       childA.setID("childA");
       root.insert(childA);


       NodeModel childB = new NodeModel(map);
       childB.setID("childB");
       childA.insert(childB);


       map.registryNode(childA);
       map.registryNode(childB);


       assertEquals(childA, root.getChildAt(0));
       assertEquals(childB, childA.getChildAt(0));
       assertEquals(childB, map.getNodeForID("childB"));
   }


Class 3
Selected Class
NodeRelativePath.java
Directory:
freeplane/src/main/java/org/freeplane/features/map/NodeRelativePath.java
Test Suite
All tests are placed in:
freeplane/src/test/java/org/freeplane/features/map/NodeRelativePathClassTest.java
Tests:
testCreateNodeRelativePath(): Test creating a NodeRelativePath from the same node. Path length should be 0.
testPathBeginAndEnd(): Test pathBegin and pathEnd when the source and destination are the same node.
testCompareSameNode(): Test compareNodePositions for the same node, result should be 0.
testEqualPaths(): Test equalPathsTo method for two identical NodeRelativePath objects. Should return true.
testDifferentPathsNotEqual(): Test equalPathsTo method for two different NodeRelativePath objects. Should return false.
testPathLengthZero(): Test that a NodeRelativePath from a node to itself has path length 0.
testPathLengthOne(): Test that a NodeRelativePath from a child node to parent has path length 1.
testPathBeginAtLevel(): Test pathBegin method when traversing a simple child node structure.
testPathEndAtLevel(): Test pathEnd method when traversing a simple child node structure.
Test Outcomes
[Test Result](./Class 3 files/class3TestResult.PNG)
Additional Classes
NodeModel
(freeplane\src\main\java\org\freeplane\features\map\NodeModel.java)
Represents a single node in the mind map. It holds the node's content, style, and structure, including links to parent and child nodes. NodeModel manages node-level operations such as inserting, removing, cloning, and accessing nodes within the hierarchical map structure.
SingleNodeList
(freeplane\src\main\java\org\freeplane\features\map\SingleNodeList.java)
A lightweight container class that holds a single NodeModel object. It provides a list-like interface for cases where a node needs to represent a clone or a simplified child list. Used internally by NodeModel to manage clone relationships without the overhead of full list structures.
Bottom-Up Testing
Code (was placed in
freeplane/src/test/java/org/freeplane/features/map/NodeModelAndSingleNodeListSpec.java )
@Test
public void NodeModelCreate() {
	MapModel map = null;
	NodeModel node = new NodeModel("root", map);
	assertEquals("root", node.getUserObject());
}

Test creating a NodeModel with a specific userObject and verifying that getUserObject() correctly returns the initial value.
@Test
public void NodeModelInsertChild() {
	MapModel map = null;
	NodeModel parent = new NodeModel("parent", map);
	NodeModel child = new NodeModel("child", map);
	parent.insert(child);
	assertEquals(1, parent.getChildCount());
}

Test inserting a child node into a parent NodeModel, and check whether the number of children increases correctly.
@Test
public void NodeModelGetChildAt() {
	MapModel map = null;
	NodeModel parent = new NodeModel("parent", map);
	NodeModel child = new NodeModel("child", map);
	parent.insert(child);
	assertEquals(child, parent.getChildAt(0));
}

Test whether the inserted child can be retrieved using getChildAt(0) from the parent node.
@Test
public void NodeModelSetUserObject() {
	MapModel map = null;
	NodeModel node = new NodeModel("old", map);
	node.setUserObject("new");
	assertEquals("new", node.getUserObject());
}

Test setting a new userObject value to a node and verify the update using getUserObject().
@Test
public void SingleNodeListCreate() {
	MapModel map = null;
	NodeModel node = new NodeModel("single", map);
	SingleNodeList list = new SingleNodeList(node, null);
	assertNotNull(list);
}
Test creation of a SingleNodeList and ensure it is not null after initialization.
@Test
public void SingleNodeListIterate() {
	MapModel map = null;
	NodeModel node = new NodeModel("single", map);
	SingleNodeList list = new SingleNodeList(node, null);

	NodeModel iteratedNode = null;
	for (NodeModel n : list) {
    	iteratedNode = n;
	}
	assertEquals(node, iteratedNode);
}

Test whether SingleNodeList supports iteration and whether it returns the expected single element during a for-each loop.
[Bottom Up Test Result](./Class 3 files/class3TestBottomUp.PNG)
Class 4

Selected Class

NodeMatcher.java

Directory:
freeplane/src/main/java/org/freeplane/features/explorer/NodeMatcher.java

Test Suite

(Testing directly on original code)
To get Test Coverage (using jacoco)

Add to freeplane/bulid.gradle

plugins {
  id 'jacoco'
}

Add to freeplane/freeplane/bulid.gradle
apply plugin: 'jacoco'

jacocoTestReport {
    dependsOn test // tests are required to run before generating the report
    reports {
        xml.required = false
        csv.required = false
        html.outputLocation = layout.buildDirectory.dir('jacocoHtml')
    }
}

test {
    finalizedBy jacocoTestReport
}

Test commands:
gradle test

Tests:
All test in different file here [code](./Class 4 files/NodeMatcherSpec.java)
(was place in freeplane/src/test/java/org/freeplane/features/explorer/NodeMatcherSpec.java)

matches() matches property of node to check if it matches node.

filterMatchingNodes() filters all matching nodes that has property

NodeMatcherBlank(): Test matches() with blank test string, in addition should test no_content enum

NodeMatcherAlias(): Test matches() with a node alias, in addition should test alias enum

NodeMatcherTextFullTrue1(): Test matches() with text that has double quotation marks.

NodeMatcherTextFullTrue2(): Test matches() with text that has single quotation marks.

NodeMatcherTextPartTrue1(): Test matches() with text that has double quotation marks and ellipsis.

NodeMatcherTextPartTrue2(): Test matches() with text that has single quotation marks and ellipsis.

NodeMatcherTextFullFalse(): Test matches() with text when text doesn’t match node

NodeMatcherInvalid(): Test matches() with invalid search string

NodeMatcherCounterMatch(): Test matches() with counter, will return error as counter is used for filterMatchingNodes()

NodeMatcherList(): Test filterMatchingNodes() with text.

NodeMatcherCounter(): Test filterMatchingNodes() with counter, within node list range.

NodeMatcherCounterEmpty(): Test filterMatchingNodes() with counter, outside node list range.

Test Outcomes

[Test Coverage](./Class 4 files/class4TestCoverage.PNG)
(some branches are impossible while some are too minor and overlap)

[Test Result](./Class 4 files/class4TestResult.PNG)

Additional Classes

Command
(freeplane/src/main/java/org/freeplane/features/explorer/Command.java)

A Class which functions with ExploringStep to control operations of NodeMatcher. Calls NodeMatcher 

ExploringStep
(freeplane/src/main/java/org/freeplane/features/explorer/ExploringStep.java)

An Enum Class where its methods vary depending on its enum type. Calls NodeMatcher 

Bottom-Up Testing

(was place in freeplane/src/test/java/org/freeplane/features/explorer/Command.java)
[code](./Class 4 files/CommandSpec.java)

   @Test
    public void CommandChild() throws Exception {
        AccessedNodes accessedNodes = mock(AccessedNodes.class);
        NodeModel parent = new NodeModel("", null);

        parent.insert(new NodeModel("a", null));
        parent.insert(new NodeModel("b", null));
        parent.insert(new NodeModel("c", null));
        parent.insert(new NodeModel("d", null));

        Command command = new Command(ExploringStep.CHILD, "\'b\'", accessedNodes);

        assertEquals(command.getNodes(parent).toString(), "[b]");
    }

Code test dependency of NodeMatcher, Command and ExploringStep. Command creates NodeMatcher when it is created with search string “\’b\’”, while ExploringStep is type CHILD hence getNode (of ExploringStep) will search for the child nodes of the node selected when Command method getNodes is called. 

    @Test
    public void CommandDescendant() throws Exception {
        AccessedNodes accessedNodes = mock(AccessedNodes.class);
        NodeModel parent = new NodeModel("", null);

        parent.insert(new NodeModel("a", null));
        NodeModel node = new NodeModel("b", null);
        node.insert(new NodeModel("d", null));
        parent.insert(node);
        parent.insert(new NodeModel("c", null));

        Command command = new Command(ExploringStep.DESCENDANT, "\'d\'", accessedNodes);

        assertEquals(command.getNodes(parent).toString(), "[d]");
    }

Changed ExploringStep type to DESCENDANT hence will check descendants of nodes. This checks the descendant ‘d’ of ‘parent’ which is a child of ‘b’.

   @Test
    public void CommandAncestor() throws Exception {
        AccessedNodes accessedNodes = mock(AccessedNodes.class);
        NodeModel parent = new NodeModel("a", null);

        parent.insert(new NodeModel("e", null));
        NodeModel nodeB = new NodeModel("b", null);
        NodeModel nodeC = new NodeModel("c", null);
        nodeB.insert(nodeC);
        parent.insert(nodeB);
        parent.insert(new NodeModel("d", null));

        Command command = new Command(ExploringStep.ANCESTOR, "\'a\'", accessedNodes);

        assertEquals(command.getNodes(nodeC).toString(), "[a]");
    }

Changed ExploringStep type to ANCESTOR hence will check ancestors of the node. This code checks the ancestor of ‘c’, ‘a’.

    @Test
    public void CommandString() throws Exception {
        AccessedNodes accessedNodes = mock(AccessedNodes.class);

        Command command = new Command(ExploringStep.CHILD, "\'a\'", accessedNodes);

        assertEquals(command.toString(), "Command [operator=CHILD, searchedString='a']");
    }

Checked toString method of command showing its ExploringStep type and searchedString.

[Bottom Up Test Result](./Class 4 files/class4TestBottomUp.PNG)

Class 5
Selected Class
NodeStyleController.java
Directory:
freeplane/src/main/java/org/freeplane/features/nodestyle/NodeStyleController.java

Test Suite
Ensure dependencies are present in build.gradle (freeplane/freeplane/build.gradle):
testImplementation 'org.junit.jupiter:junit-jupiter:5.9.3'
testImplementation 'org.mockito:mockito-core:5.2.0'
testImplementation 'org.assertj:assertj-core:3.26.0'
test {
    useJUnitPlatform()
}
Place the test file at: freeplane/freeplane/src/test/java/org/freeplane/features/nodestyle/NodeStyleControllerTest.java
test {
    useJUnitPlatform() // Enable JUnit 5 platform support
}
testGetFont_UsesNodeStyleModelOverride: Verifies getFont prioritizes font attributes from the node's NodeStyleModel when present (mocked).
testGetFont_UsesAppliedStyleWhenNoOverride: Checks getFont uses attributes from the logical style (obtained via mocked LogicalStyleController) if no node override exists.
testGetFont_UsesDefaultWhenNoStyle: Ensures getFont returns the system default font when neither node nor style provides font information.
testGetColor_PrecedenceCheck: Verifies getColor correctly follows precedence: node's NodeStyleModel > applied style > default color.
testGetBackgroundColor_PrecedenceCheck: Similar test for getBackgroundColor.
testGetShapeConfiguration_PrecedenceCheck: Verifies getShapeConfiguration follows precedence: node's NodeStyleModel > applied style > default (AS_PARENT).
testGetMaxWidth_MinWidth_PrecedenceCheck: Verifies getMaxWidth/getMinWidth follows precedence: node's NodeSizeModel > applied style > default values.
testGetBorderProperties_PrecedenceCheck: Verifies retrieval for border properties (Color, Width, Dash, etc.) follows precedence: node's NodeBorderModel > applied style > defaults.
testIsBold_Italic_StrikedThrough_ComputedCorrectly: Checks boolean style methods return correct values based on the final computed font from various sources.

Test Outcomes
Ensure that all style-related methods work as expected.
Verify that styles are correctly applied, inherited, and persisted.
Confirm that invalid operations are handled gracefully.

Additional Classes
NodeModel.java (freeplane/src/main/java/org/freeplane/features/map/NodeModel.java)
Description: Holds node data and extensions (NodeStyleModel, etc.). In unit tests, it's mocked. In bottom-up tests, its state (and attached extensions) is verified after controller actions. Unit tested in Class 1.
NodeStyleModel.java (freeplane/src/main/java/org/freeplane/features/nodestyle/NodeStyleModel.java)
Description: Stores node-specific style overrides. Mocked in unit tests. State verified in bottom-up tests after actions from MNodeStyleController. Assumed unit-tested.
NodeSizeModel.java (freeplane/src/main/java/org/freeplane/features/nodestyle/NodeSizeModel.java)
Description: Stores node-specific size constraints. Mocked in unit tests. State verified in bottom-up tests. Assumed unit-tested.
NodeBorderModel.java (freeplane/src/main/java/org/freeplane/features/nodestyle/NodeBorderModel.java)
Description: Stores node-specific border properties. Mocked in unit tests. State verified in bottom-up tests. Assumed unit-tested.
MNodeStyleController.java (freeplane/src/main/java/org/freeplane/features/nodestyle/mindmapmode/MNodeStyleController.java)
Description: Subclass providing actions (setColor, setBold, etc.) that modify the style models. These actions are the focus of the bottom-up integration tests.

Bottom-Up Testing
File:freeplane/src/test/java/org/freeplane/features/nodestyle/NodeStyleModificationIntegrationTest.java

import org.freeplane.features.map.NodeModel;
import org.freeplane.features.nodestyle.NodeStyleModel;
import org.freeplane.features.nodestyle.NodeSizeModel;
import org.freeplane.features.nodestyle.NodeBorderModel;
import org.freeplane.features.nodestyle.mindmapmode.MNodeStyleController;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class NodeStyleModificationIntegrationTest {

    @Test
    public void testSetStyle() {
        // Initialize lower-level class
        NodeModel node = new NodeModel("Test Node", null);
        NodeStyleModel style = new NodeStyleModel();
        style.setFontFamily("Arial");
        style.setFontSize(14);

        // Use MNodeStyleController to modify style
        MNodeStyleController controller = new MNodeStyleController(null);
        controller.setNodeStyle(node, style);

        // Verify interaction and state
        assertEquals(style, NodeStyleModel.getNodeStyle(node));
        assertEquals("Arial", NodeStyleModel.getFontFamily(node));
        assertEquals(14, NodeStyleModel.getFontSize(node));
    }

    @Test
    public void testRemoveStyle() {
        // Initialize with a style
        NodeModel node = new NodeModel("Test Node", null);
        NodeStyleModel style = new NodeStyleModel();
        style.setFontFamily("Arial");
        MNodeStyleController controller = new MNodeStyleController(null);
        controller.setNodeStyle(node, style);

        // Remove style and verify
        controller.setNodeStyle(node, null);
        assertNull(NodeStyleModel.getNodeStyle(node));
    }

    @Test
    public void testApplyStyleToChildren() {
        // Create parent-child hierarchy
        NodeModel parent = new NodeModel("Parent", null);
        NodeModel child = new NodeModel("Child", null);
        parent.insert(child);

        // Apply style to parent
        NodeStyleModel style = new NodeStyleModel();
        style.setFontFamily("Helvetica");
        style.setFontSize(12);
        MNodeStyleController controller = new MNodeStyleController(null);
        controller.setNodeStyle(parent, style);

        // Propagate style to children
        controller.copyStyleToChildren(parent);

        // Verify child inherited style
        assertEquals("Helvetica", NodeStyleModel.getFontFamily(child));
        assertEquals(12, NodeStyleModel.getFontSize(child));
    }

    @Test
    public void testSetBorderProperties() {
        // Initialize node and border model
        NodeModel node = new NodeModel("Test Node", null);
        NodeBorderModel border = new NodeBorderModel();
        border.setBorderWidth(2);
        border.setBorderColor(Color.RED);

        // Use MNodeStyleController to set border
        MNodeStyleController controller = new MNodeStyleController(null);
        controller.setBorderModel(node, border);

        // Verify interaction and state
        assertEquals(2, NodeBorderModel.getBorderWidth(node));
        assertEquals(Color.RED, NodeBorderModel.getBorderColor(node));
    }

    @Test
    public void testSetSizeConstraints() {
        // Initialize node and size model
        NodeModel node = new NodeModel("Test Node", null);
        NodeSizeModel size = new NodeSizeModel();
        size.setMaxNodeWidth(200);
        size.setMinNodeWidth(50);

        // Use MNodeStyleController to set size
        MNodeStyleController controller = new MNodeStyleController(null);
        controller.setNodeSizeModel(node, size);

        // Verify interaction and state
        assertEquals(200, NodeSizeModel.getMaxNodeWidth(node));
        assertEquals(50, NodeSizeModel.getMinNodeWidth(node));
    }
}

