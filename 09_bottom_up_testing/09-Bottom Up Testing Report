Class 1
Selected Class
Test Suite
Test Outcomes
Additional Classes
Bottom-Up Testing

Class 2
Selected Class
Test Suite
Test Outcomes
Additional Classes
Bottom-Up Testing

Class 3
Selected Class
NodeRelativePath.java
Directory:
freeplane/src/main/java/org/freeplane/features/map/NodeRelativePath.java
Test Suite
All tests are placed in:
freeplane/src/test/java/org/freeplane/features/map/NodeRelativePathClassTest.java
Tests:
testCreateNodeRelativePath(): Test creating a NodeRelativePath from the same node. Path length should be 0.
testPathBeginAndEnd(): Test pathBegin and pathEnd when the source and destination are the same node.
testCompareSameNode(): Test compareNodePositions for the same node, result should be 0.
testEqualPaths(): Test equalPathsTo method for two identical NodeRelativePath objects. Should return true.
testDifferentPathsNotEqual(): Test equalPathsTo method for two different NodeRelativePath objects. Should return false.
testPathLengthZero(): Test that a NodeRelativePath from a node to itself has path length 0.
testPathLengthOne(): Test that a NodeRelativePath from a child node to parent has path length 1.
testPathBeginAtLevel(): Test pathBegin method when traversing a simple child node structure.
testPathEndAtLevel(): Test pathEnd method when traversing a simple child node structure.
Test Outcomes
[Test Result](./Class 3 files/class3TestResult.PNG)
Additional Classes
NodeModel
(freeplane\src\main\java\org\freeplane\features\map\NodeModel.java)
Represents a single node in the mind map. It holds the node's content, style, and structure, including links to parent and child nodes. NodeModel manages node-level operations such as inserting, removing, cloning, and accessing nodes within the hierarchical map structure.
SingleNodeList
(freeplane\src\main\java\org\freeplane\features\map\SingleNodeList.java)
A lightweight container class that holds a single NodeModel object. It provides a list-like interface for cases where a node needs to represent a clone or a simplified child list. Used internally by NodeModel to manage clone relationships without the overhead of full list structures.
Bottom-Up Testing
Code (was placed in
freeplane/src/test/java/org/freeplane/features/map/NodeModelAndSingleNodeListSpec.java )
@Test
public void NodeModelCreate() {
	MapModel map = null;
	NodeModel node = new NodeModel("root", map);
	assertEquals("root", node.getUserObject());
}

Test creating a NodeModel with a specific userObject and verifying that getUserObject() correctly returns the initial value.
@Test
public void NodeModelInsertChild() {
	MapModel map = null;
	NodeModel parent = new NodeModel("parent", map);
	NodeModel child = new NodeModel("child", map);
	parent.insert(child);
	assertEquals(1, parent.getChildCount());
}

Test inserting a child node into a parent NodeModel, and check whether the number of children increases correctly.
@Test
public void NodeModelGetChildAt() {
	MapModel map = null;
	NodeModel parent = new NodeModel("parent", map);
	NodeModel child = new NodeModel("child", map);
	parent.insert(child);
	assertEquals(child, parent.getChildAt(0));
}

Test whether the inserted child can be retrieved using getChildAt(0) from the parent node.
@Test
public void NodeModelSetUserObject() {
	MapModel map = null;
	NodeModel node = new NodeModel("old", map);
	node.setUserObject("new");
	assertEquals("new", node.getUserObject());
}

Test setting a new userObject value to a node and verify the update using getUserObject().
@Test
public void SingleNodeListCreate() {
	MapModel map = null;
	NodeModel node = new NodeModel("single", map);
	SingleNodeList list = new SingleNodeList(node, null);
	assertNotNull(list);
}
Test creation of a SingleNodeList and ensure it is not null after initialization.
@Test
public void SingleNodeListIterate() {
	MapModel map = null;
	NodeModel node = new NodeModel("single", map);
	SingleNodeList list = new SingleNodeList(node, null);

	NodeModel iteratedNode = null;
	for (NodeModel n : list) {
    	iteratedNode = n;
	}
	assertEquals(node, iteratedNode);
}

Test whether SingleNodeList supports iteration and whether it returns the expected single element during a for-each loop.
[Bottom Up Test Result](./Class 3 files/class3TestBottomUp.PNG)
Class 4

Selected Class

NodeMatcher.java

Directory:
freeplane/src/main/java/org/freeplane/features/explorer/NodeMatcher.java

Test Suite

(Testing directly on original code)
To get Test Coverage (using jacoco)

Add to freeplane/bulid.gradle

plugins {
  id 'jacoco'
}

Add to freeplane/freeplane/bulid.gradle
apply plugin: 'jacoco'

jacocoTestReport {
    dependsOn test // tests are required to run before generating the report
    reports {
        xml.required = false
        csv.required = false
        html.outputLocation = layout.buildDirectory.dir('jacocoHtml')
    }
}

test {
    finalizedBy jacocoTestReport
}

Test commands:
gradle test

Tests:
All test in different file here [code](./Class 4 files/NodeMatcherSpec.java)
(was place in freeplane/src/test/java/org/freeplane/features/explorer/NodeMatcherSpec.java)

matches() matches property of node to check if it matches node.

filterMatchingNodes() filters all matching nodes that has property

NodeMatcherBlank(): Test matches() with blank test string, in addition should test no_content enum

NodeMatcherAlias(): Test matches() with a node alias, in addition should test alias enum

NodeMatcherTextFullTrue1(): Test matches() with text that has double quotation marks.

NodeMatcherTextFullTrue2(): Test matches() with text that has single quotation marks.

NodeMatcherTextPartTrue1(): Test matches() with text that has double quotation marks and ellipsis.

NodeMatcherTextPartTrue2(): Test matches() with text that has single quotation marks and ellipsis.

NodeMatcherTextFullFalse(): Test matches() with text when text doesn’t match node

NodeMatcherInvalid(): Test matches() with invalid search string

NodeMatcherCounterMatch(): Test matches() with counter, will return error as counter is used for filterMatchingNodes()

NodeMatcherList(): Test filterMatchingNodes() with text.

NodeMatcherCounter(): Test filterMatchingNodes() with counter, within node list range.

NodeMatcherCounterEmpty(): Test filterMatchingNodes() with counter, outside node list range.

Test Outcomes

[Test Coverage](./Class 4 files/class4TestCoverage.PNG)
(some branches are impossible while some are too minor and overlap)

[Test Result](./Class 4 files/class4TestResult.PNG)

Additional Classes

Command
(freeplane/src/main/java/org/freeplane/features/explorer/Command.java)

A Class which functions with ExploringStep to control operations of NodeMatcher. Calls NodeMatcher 

ExploringStep
(freeplane/src/main/java/org/freeplane/features/explorer/ExploringStep.java)

An Enum Class where its methods vary depending on its enum type. Calls NodeMatcher 

Bottom-Up Testing

(was place in freeplane/src/test/java/org/freeplane/features/explorer/Command.java)
[code](./Class 4 files/CommandSpec.java)

   @Test
    public void CommandChild() throws Exception {
        AccessedNodes accessedNodes = mock(AccessedNodes.class);
        NodeModel parent = new NodeModel("", null);

        parent.insert(new NodeModel("a", null));
        parent.insert(new NodeModel("b", null));
        parent.insert(new NodeModel("c", null));
        parent.insert(new NodeModel("d", null));

        Command command = new Command(ExploringStep.CHILD, "\'b\'", accessedNodes);

        assertEquals(command.getNodes(parent).toString(), "[b]");
    }

Code test dependency of NodeMatcher, Command and ExploringStep. Command creates NodeMatcher when it is created with search string “\’b\’”, while ExploringStep is type CHILD hence getNode (of ExploringStep) will search for the child nodes of the node selected when Command method getNodes is called. 

    @Test
    public void CommandDescendant() throws Exception {
        AccessedNodes accessedNodes = mock(AccessedNodes.class);
        NodeModel parent = new NodeModel("", null);

        parent.insert(new NodeModel("a", null));
        NodeModel node = new NodeModel("b", null);
        node.insert(new NodeModel("d", null));
        parent.insert(node);
        parent.insert(new NodeModel("c", null));

        Command command = new Command(ExploringStep.DESCENDANT, "\'d\'", accessedNodes);

        assertEquals(command.getNodes(parent).toString(), "[d]");
    }

Changed ExploringStep type to DESCENDANT hence will check descendants of nodes. This checks the descendant ‘d’ of ‘parent’ which is a child of ‘b’.

   @Test
    public void CommandAncestor() throws Exception {
        AccessedNodes accessedNodes = mock(AccessedNodes.class);
        NodeModel parent = new NodeModel("a", null);

        parent.insert(new NodeModel("e", null));
        NodeModel nodeB = new NodeModel("b", null);
        NodeModel nodeC = new NodeModel("c", null);
        nodeB.insert(nodeC);
        parent.insert(nodeB);
        parent.insert(new NodeModel("d", null));

        Command command = new Command(ExploringStep.ANCESTOR, "\'a\'", accessedNodes);

        assertEquals(command.getNodes(nodeC).toString(), "[a]");
    }

Changed ExploringStep type to ANCESTOR hence will check ancestors of the node. This code checks the ancestor of ‘c’, ‘a’.

    @Test
    public void CommandString() throws Exception {
        AccessedNodes accessedNodes = mock(AccessedNodes.class);

        Command command = new Command(ExploringStep.CHILD, "\'a\'", accessedNodes);

        assertEquals(command.toString(), "Command [operator=CHILD, searchedString='a']");
    }

Checked toString method of command showing its ExploringStep type and searchedString.

[Bottom Up Test Result](./Class 4 files/class4TestBottomUp.PNG)

Class 5
Selected Class
Test Suite
Test Outcomes
Additional Classes
Bottom-Up Testing
